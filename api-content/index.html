{"posts":[{"title":"队列Queue及实现","content":"article_content 一：队列Queue 队列是一种特殊的线性表，遵循先入先出、后入后出的基本原则，一般来说，它只允许在表的前端进行删除操作，而在表的后端进行插入操作，但是java的某些队列运行在任何地方插入删除；比如我们常用的 LinkedList 集合，它实现了Queue 接口，因此，我们可以理解为&nbsp;LinkedList 就是一个队列； 1：队列特性 队列主要分为阻塞和非阻塞，有界和无界、单向链表和双向链表之分； 阻塞和非阻塞 阻塞队列 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;入列(添加元素)时，如果元素数量超过队列总数，会进行等待（阻塞），待队列的中的元素出列后，元素数量未超过队列总数时，就会解除阻塞状态，进而可以继续入列； &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;出列(删除元素)时，如果队列为空的情况下，也会进行等待（阻塞），待队列有值的时候即会解除阻塞状态，进而继续出列； &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 阻塞队列的好处是可以防止队列容器溢出；只要满了就会进行阻塞等待；也就不存在溢出的情况； &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 只要是阻塞队列，都是线程安全的； &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 非阻塞队列 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 不管出列还是入列，都不会进行阻塞， &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;入列时，如果元素数量超过队列总数，则会抛出异常， &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 出列时，如果队列为空，则取出空值； 一般情况下，非阻塞式队列使用的比较少，一般都用阻塞式的对象比较多；阻塞和非阻塞队列在使用上的最大区别就是阻塞队列提供了以下2个方法： &nbsp; &nbsp; 出队阻塞方法 ：&nbsp;take()&nbsp; &nbsp; 入队阻塞方法 ：&nbsp;put() &nbsp; 有界和无界 &nbsp;&nbsp; &nbsp;有界：有界限，大小长度受限制 &nbsp;&nbsp; &nbsp;无界：无限大小，其实说是无限大小，其实是有界限的，只不过超过界限时就会进行扩容，就行ArrayList 一样，在内部动态扩容 &nbsp; &nbsp; 单向链表和双向链表 单向链表 ：&nbsp;每个元素中除了元素本身之外，还存储一个指针，这个指针指向下一个元素； 双向链表 ：除了元素本身之外，还有两个指针，一个指针指向前一个元素的地址，另一个指针指向后一个元素的地址； 2：Java 队列接口继承图 &nbsp; 3：队列常用方法 add&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;增加一个元索&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果队列已满，则抛出一个IIIegaISlabEepeplian异常 remove&nbsp;&nbsp;&nbsp;移除并返回队列头部的元素&nbsp;&nbsp;&nbsp;&nbsp;如果队列为空，则抛出一个NoSuchElementException异常 element&nbsp;&nbsp;返回队列头部的元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果队列为空，则抛出一个NoSuchElementException异常 offer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;添加一个元素并返回true&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果队列已满，则返回false poll&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;移除并返问队列头部的元素&nbsp;&nbsp;&nbsp;&nbsp;如果队列为空，则返回null peek&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回队列头部的元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果队列为空，则返回null put&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;添加一个元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果队列满，则阻塞 take&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;移除并返回队列头部的元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果队列为空，则阻塞 &nbsp; &nbsp; &nbsp; &nbsp;drainTo(list)&nbsp; &nbsp;一次性取出队列所有元素 知识点： remove、element、offer&nbsp;、poll、peek&nbsp;其实是属于Queue接口。&nbsp; 4：阻塞队列与非阻塞队列具体详解 非阻塞队列： 1、ConcurrentLinkedQueue &nbsp; 单向链表结构的无界并发队列, 非阻塞队列，由CAS实现线程安全，内部基于节点实现 2、ConcurrentLinkedDeque &nbsp; 双向链表结构的无界并发队列, 非阻塞队列，由CAS实现线程安全&nbsp; &nbsp;&nbsp; 3、PriorityQueue 内部基于数组实现，线程不安全的队列 阻塞队列： 1、DelayQueue 一个支持延时获取元素的无界阻塞队列 2、LinkedTransferQueue 一个由链表结构组成的无界阻塞队列。 Java并发包--LinkedBlockingDeque - ken007 - 博客园 3、ArrayBlockingQueue 有界队列，阻塞式,初始化时必须指定队列大小，且不可改变；，底层由数组实现； 4、SynchronousQueue 最多只能存储一个元素，每一个put操作必须等待一个take操作，否则不能继续添加元素 5、PriorityBlockingQueue 一个带优先级的队列，而不是先进先出队列。元素按优先级顺序被移除，而且它也是无界的，也就是没有容量上限，虽然此队列逻辑上是无界的，但是由于资源被耗尽，所以试图执行添加操作可能会导致 OutOfMemoryError 错误； 博客： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。（LinkedBlockingDeque还是可选容量的(防止过度膨胀)，即可以指定队列的容量。如果不指定，默认容量大小等于Integer.MAX_VALUE（@Native public static final int MAX_VALUE = 0x7fffffff）） ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。&nbsp; LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。&nbsp; PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。&nbsp; LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。&nbsp; SynchronousQueue：一个不存储元素的阻塞队列。&nbsp; DealyQueue：一个使用优先级队列实现的无界阻塞队列。&nbsp; 高并发第十三弹:J.U.C 队列 SynchronousQueue.ArrayBlockingQueue.LinkedBlockingQueue.LinkedTransferQueue - 爱呼吸的鱼 - 博客园 二：双端队列Deque 双端队列既可以当作队列也可以当作栈！方法中可以先入先出也可以先入后出，因为是双端的，所以栈我们不推荐使用Vector的实现类Stack，推荐使用双端队列ArrayDeque来做栈。 Deque———ArrayDeque类详解 类型方法作用添加元素public void addFirst(E e)在数组前面添加元素public void addLast(E e)在数组后面添加元素public boolean offerFirst(E e)在数组前面添加元素，并返回是否添加成功public boolean offerLast在数组后面添加元素，并返回是否添加成功删除元素public E pollFirst()删除第一个元素，并返回删除元素的值，如果元素为null，将返回nullpublic E removeFirst()删除第一个元素，并返回删除元素的值,如果元素为null，将抛出异常public E pollLast()删除最后一个元素，并返回删除元素的值，如果为null，将返回nullpublic E removeLast()删除最后一个元素，并返回删除元素的值，如果为null，将抛出异常public boolean removeFirstOccurrence(Object o)删除第一次出现的指定元素public boolean removeLastOccurrence(Object o)删除最后一次出现的指定元素获取元素public E getFirst()获取第一个元素,如果没有将抛出异常public E getLast()获取最后一个元素，如果没有将抛出异常队列操作public boolean add(E e)在队列尾部添加一个元素public boolean offer(E e)在队列尾部添加一个元素，并返回是否成功public E remove()删除队列中第一个元素，并返回该元素的值，如果元素为null，将抛出异常(其实底层调用的是removeFirst())public E poll()删除队列中第一个元素，并返回该元素的值,如果元素为null，将返回null(其实调用的是pollFirst())public E element()获取第一个元素，如果没有将抛出异常public E peek()获取第一个元素，如果返回null栈操作public void push(E e)栈顶添加一个元素public E pop()移除栈顶元素,如果栈顶没有元素将抛出异常其他public int size()获取队列中元素个数public boolean isEmpty()判断队列是否为空public Iterator iterator()迭代器，从前向后迭代public Iterator descendingIterator()迭代器，从后向前迭代public boolean contains(Object o)判断队列中是否存在该元素public Object[] toArray()转成数组public T[] toArray(T[] a)转成a数组常public void clear()清空队列public ArrayDeque clone()克隆(复制)一个新的队列 六.参考资料 1.数据结构 ArrayDeque类是&nbsp;双端队列的线性实现类。 具有以下特征： ☞&nbsp;ArrayDeque是采用数组方式实现的双端队列。 ☞ ArrayDeque的出队入队是通过头尾指针循环，利用数组实现的。 ☞ ArrayDeque容量不足时是会扩容的，每次扩容容量增加一倍。 ☞ ArrayDeque可以直接作为栈使用。当用作栈时，性能优于Stack，当用于队列时，性能优于LinkedList。 ☞ 无容量大小限制，容量按需增长。 ☞ 非线程安全队列，无同步策略，不支持多线程安全访问。 ☞ 具有fail-fast特性，不能存储null值，支持双向迭代器遍历。 ArrayDeque的实现结构图如下所示: 2.类标题 ArrayDeque类的标题如下： public class ArrayDeque extends AbstractCollection implements&nbsp;Deque, Cloneable, Serializable 这个标题说明ArrayDeque类是AbstractCollection类的子类，并且实现了三个接口：Deque、Cloneable和Serializable。 如下图所示： 1.ArrayDeque实现了Deque接口，即能将LinkedList当做双端队列使用。 2.ArrayDeque实现了Cloneable接口，即覆盖了函数clone()，能克隆。 3.ArrayDeque实现java.io.Serializable接口，LinkedList支持序列化，能通过序列化去传输。 4.ArrayDeque是非同步的[2]。 【注2】在这里的非同步指的是,当使用线程的时候,对于这个集合对象进行操作,那么不同的线程所获取的这个集合对象是不同的.所以是说不同步,在多线程的形式是不安全的. 3.字段 transient Object[] elements; 存储元素的数组 transient int head; 队列头位置 transient int tail; 队列尾位置 private static final int MIN_INITIAL_CAPACITY = 8; 一个新创建的队列的最小容量 4.构造函数 4.1 无参的构造方法,创建一个容量为16的ArrayDeque 源码如下： public ArrayDeque() { //无参构造函数，默认的底层数组大小为16. elements = new Object[16]; } 4.2 有参的构造方法，创建一个指定大小的ArrayDeque 源码如下： public ArrayDeque(int numElements) { //如果指定初始容量小于8，将会返回容量为8的新数组。 allocateElements(numElements); //调用allocateElements方法，分配新数组 } private void allocateElements(int numElements) { int initialCapacity = MIN_INITIAL_CAPACITY; //做移位与运算最后加一得到比给定长度大的最小的2的幂数。 if (numElements &gt;= initialCapacity) { initialCapacity = numElements; initialCapacity |= (initialCapacity &gt;&gt;&gt; 1); initialCapacity |= (initialCapacity &gt;&gt;&gt; 2); initialCapacity |= (initialCapacity &gt;&gt;&gt; 4); initialCapacity |= (initialCapacity &gt;&gt;&gt; 8); initialCapacity |= (initialCapacity &gt;&gt;&gt; 16); initialCapacity++; if (initialCapacity &lt; 0) // Too many elements, must back off initialCapacity &gt;&gt;&gt;= 1;// Good luck allocating 2 ^ 30 elements } elements = new Object[initialCapacity]; } 源码分析：对于一个给定长度，先判断是否小于定义的最小长度，如果小于，则使用定义的最小长度作为数组的长度。否则，找到比给定长度大的最小的2的幂数（在if里面的语句实现这一功能）。 如下图所示： 【注】 \"&gt;&gt;&gt;\"表示无符号右移，也叫逻辑右移。即若该数为正，则高位补0，若该数为负数，则右移后高位同样补0. 4.3 有参的构造方法，将现有集合元素C加入队列进行构造 源码如下： public ArrayDeque(Collection&lt;? extends E&gt; c) { allocateElements(c.size());//调用上述allocateElements()方法，分配型数组内存空间。 addAll(c);//调用addAll()方法，将现有集合元素c添加到ArrayDeque中。 } //addAll(Collection c) inherited from AbstractCollection public boolean addAll(Collection&lt;? extends E&gt; c) { boolean modified = false; for (E e : c) if (add(e)) modified = true; return modified; }//将集合元素添加到ArrayDeque末尾 public boolean add(E e) { addLast(e);//addLast()方法作用为：在最后一个元素后面添加元素。详见下述public void addLast(E e)。 return true; } 源码分析： 先根据已有集合c大小，通过allocateElement()方法创建最小的2的幂数的数组空间。addAll()将c中元素通过add()逐个添加到型数组中。 5.方法分析 添加元素 public void addFirst(E e)作用:在ArrayDeque前面添加元素。 源码如下: public void addFirst(E e) { if (e == null) throw new NullPointerException(); elements[head = (head - 1) &amp; (elements.length - 1)] = e;//将元素e添加到ArrayDeque双端队列的队首位置。 if (head == tail)//(head == tail)判定内存不足 doubleCapacity();//进行扩容操作 } //扩容为原来的两倍 private void doubleCapacity() { assert head == tail; int p = head; int n = elements.length; int r = n - p; // number of elements to the right of p int newCapacity = n &lt;&lt; 1; if (newCapacity &lt; 0) throw new IllegalStateException(\"Sorry, deque too big\"); Object[] a = new Object[newCapacity]; System.arraycopy(elements, p, a, 0, r); System.arraycopy(elements, 0, a, r, p); elements = a; head = 0; tail = n; } //java.lang.System/* @Function:复制数组，以插入元素，但是要将index之后的元素都往后移一位。然后就是插入元素，增加sized的值 @src:源数组 srcPos:源数组要复制的起始位置 dest:目的数组 destPos:目的数组放置的起始位置 length:复制的长度*/ public static native void arraycopy(Object src,int srcPos,Object dest, int destPosint length); 源码分析：将元素插入到head前一位，同时修改head值。判断内存是否足够，若不够，扩容为原数组的两倍。然后通过System.arraycopy()，将原来数组的元素复制到新数组中。 elements[head = (head - 1) &amp; (elements.length - 1)] = e; 当head ≠ 0时 因为element数组的内存大小为2的n次幂，因此(elements.length-1),二进制为全1，[head - 1] &amp; (elements.length - 1)]值始终为head-1的值。即在element[head-1]插入元素。 当head = 0时 head - 1 = -1。其中-1用二进制表示为全1，与elements.length - 1逐位与，结果为elements.length - 1的值，即在数组的末尾插入元素。 System.arraycopy(elements, p, a, 0, r); System.arraycopy(elements, 0, a, r, p); 将elements数组从head索引(n-p)长度复制到a数组从0开始的位置。然后将elements数组从0索引开始p长度复制到a数组r索引开始的位置。 如下图所示： public void addLast(E e)作用：在ArrayDeque后面添加元素。 源码如下： public void addLast(E e) { if (e == null) throw new NullPointerException(); elements[tail] = e;//将e放到tail位置 if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head)//和head的操作类似，为了处理临界情况 (tail为length - 1时)，和length - 1进行与操作，结果为0 doubleCapacity();//将ArrayDeque容量扩展为原来的两倍。源码详见上述public void addFirst(E e) } 源码分析： 在ArrayDeque中tail索引处添加元素e。若添加元素后tail+1 == head，判定内存不足，对ArrayDeque调用doubleCapacity()进行扩容操作。 public boolean offerFirst(E e)作用：在ArrayDeque前添加一个元素，并返回是否添加成功。 源码如下： public boolean offerFirst(E e) { addFirst(e);//在ArrayDeque数组head前添加元素，addFirst()详见上述public void addFirst(). return true; } 源码分析： 调用addFirst()方法，当添加成功后返回true。 public boolean offerLast(Object o)作用：在ArrayDeque后面添加一个元素，并返回是否添加成功。 源码如下： public boolean offerLast(E e) { addLast(e);//在ArrayDeque数组tail出添加元素，addLast()详见上述public void addLast() return true; } 源码分析： 调用addLast()方法，当添加成功后返回true. public E pollFirst()作用：删除第一个元素，并返回删除元素的值。如果元素为null，将返回null. 源码如下： public E pollFirst() { int h = head; @SuppressWarnings(\"unchecked\") E result = (E) elements[h]; // Element is null if deque empty if (result == null) return null; elements[h] = null; // Must null out slot head = (h + 1) &amp; (elements.length - 1); return result; } 源码分析： 将数组的第一个元素赋值给result并返回，同时将head后移。 public E removeFirst()作用：删除第一个元素，并返回删除元素的值。如果元素为null，将抛出异常。 源码如下： public E removeFirst() { E x = pollFirst();//将删除后的值赋给x,pollFirst()详见上述pollFirst() if (x == null) throw new NoSuchElementException(); return x; } 源码分析： 调用pollFirst()返回删除的值，若返回值为null，抛出异常。 public E pollLast()作用：删除最后一个元素，并返回删除元素的值。如果元素为null，将返回null。 源码如下： public E pollLast() { int t = (tail - 1) &amp; (elements.length - 1); @SuppressWarnings(\"unchecked\") E result = (E) elements[t]; if (result == null) return null; elements[t] = null; tail = t; return result; } 源码分析： (tail - 1) &amp; (elements.length - 1)指定待删除元素的位置，并将待删除元素赋值给result.同时将数组中最后一个元素赋null值。 public E removeLast()作用：删除最后一个元素，并返回删除元素的值。如果元素为null，将抛出异常。 源码如下： public E removeLast() { E x = pollLast(); if (x == null) throw new NoSuchElementException(); return x; } 源码分析： 调用pollLast()返回删除的值，若返回值为null，抛出异常。 public boolean removeFirstOccurrence(Object o)作用：删除第一次出现的指定元素。 源码如下： public boolean removeFirstOccurrence(Object o) { if (o == null) return false; int mask = elements.length - 1; int i = head; Object x; while ( (x = elements[i]) != null) { if (o.equals(x)) { delete(i); return true; } i = (i + 1) &amp; mask;//从头到尾遍历 } return false; } 源码分析： i = (i + 1) &amp; mask; 对数组从头到尾进行遍历， 原理如下图所示： 从数组的head处对非空元素进行遍历，若数组中包含o对象，调用delete()进行删除，并返回true；否则，返回false。 private boolean delete(int i)源码如下所示： private void checkInvariants() {//有效性检查 assert elements[tail] == null;//tail位置没有元素 assert head == tail ? elements[head] == null : (elements[head] != null &amp;&amp; elements[(tail - 1) &amp; (elements.length - 1)] != null);//如果head和tail重叠，队列为空；否则heaed位置有元素，tail-1位置有元素 assert elements[(head - 1) &amp; (elements.length - 1)] == null;//head-1 的位置没有元素 } private boolean delete(int i) { checkInvariants(); final Object[] elements = this.elements; final int mask = elements.length - 1; final int h = head; final int t = tail; final int front = (i - h) &amp; mask;//i到head元素处之间的元素个数 final int back = (t - i) &amp; mask;//i到tail元素处之间的元素个数 // Invariant: head &lt;= i &lt; tail mod circularity if (front &gt;= ((t - h) &amp; mask))//i到head元素处的距离大于现有元素总数，抛出异常 throw new ConcurrentModificationException(); // Optimize for least element motion if (front &lt; back) {//i的元素靠近head,移动开始的元素，返回false. if (h &lt;= i) {//当i在head的后面 //将从head开始长度为front的数组片段复制到head+1开始的地方 System.arraycopy(elements, h, elements, h + 1, front); } else { // 当i在head的前面 //将0 ~ （i - 1)的元素后移一位，将数组最后一位元素移到数组第一位，将head后的元素后移一位。 System.arraycopy(elements, 0, elements, 1, i); elements[0] = elements[mask]; System.arraycopy(elements, h, elements, h + 1, mask - h); } elements[h] = null; head = (h + 1) &amp; mask; return false; } else {//i的位置靠近tail，移动末尾的元素，返回true. if (i &lt; t) { 当i在tail的前面 //将从i + 1开始长度为back的数组片段复制到以i开始的地方 System.arraycopy(elements, i + 1, elements, i, back); tail = t - 1; } else { //当i在tail后面 //将从i+1到数组最后一个元素往前移动一位，再将第一个元素移到最后一位。将剩余元素往前移动一位 System.arraycopy(elements, i + 1, elements, i, mask - i); elements[mask] = elements[0]; System.arraycopy(elements, 1, elements, 0, t); tail = (t - 1) &amp; mask; } return true; } } 源码分析： 为了算法的复杂度，将delete()函数分为三种情况 如下图所示： 一.待删除元素距离第一个元素比最后一个元素近 1.1 待删除元素在数组中的位置在第一个元素的后面 将从head开始长度为front的数组片段复制到head+1开始的地方。如下图所示： 1.2 待删除元素在数组中的位置在第一个元素的前面 将0 ~ （i - 1)的元素后移一位，将数组最后一位元素移到数组第一位，将head后的元素后移一位。如下图所示： 二.待删除元素距离最后一个元素比第一个元素近 2.1 待删除元素在数组中的位置在第一个元素的前面 将从i + 1开始长度为back的数组片段复制到以i开始的地方。如下图所示： 2.2 待删除元素在数组中的位置在第一个元素的后面 将从i+1到数组最后一个元素往前移动一位，再将第一个元素移到最后一位。将剩余元素往前移动一位。如下图所示： 三.待删除元素到第一个元素的距离等于到最后一个元素的距离 同情况二。 public boolean removeLastOccurrence(Object o)作用：删除最后一次出现的指定元素。 源码如下： public boolean removeLastOccurrence(Object o) { if (o == null) return false; int mask = elements.length - 1; int i = (tail - 1) &amp; mask; Object x; while ( (x = elements[i]) != null) { if (o.equals(x)) { delete(i); return true; } i = (i - 1) &amp; mask;//从尾到头遍历 } return false; } 源码分析： 从最后一个元素处对数组进行遍历，若数组中包含o对象，调用delete()进行删除，并返回true；否则，返回false。原理同上述public boolean removeFirstOccurrence(Object o)。 public E getFirst()作用：获取第一个元素，如果没有将抛出异常。 源码如下： public E getFirst() { @SuppressWarnings(\"unchecked\") E result = (E) elements[head]; if (result == null) throw new NoSuchElementException(); return result; } 源码分析： 将head索引处元素值返回。 public E getLast()作用：获取最后一个元素，如果没有将抛出异常。 源码如下： public E getLast() { @SuppressWarnings(\"unchecked\") E result = (E) elements[(tail - 1) &amp; (elements.length - 1)]; if (result == null) throw new NoSuchElementException(); return result; } 源码分析： 将最后一个元素值返回。 public boolean add(E e)作用：在队列尾部添加一个元素。 源码如下： public boolean add(E e) { addLast(e);//addLast()方法作用为：在最后一个元素后面添加元素。详见下述public void addLast(E e)。 return true; } public boolean offer(E e)作用：在队列尾部添加一个元素，并返回是否成功 源码如下： public boolean offer(E e) { return offerLast(e);//offerLast()源码分析详见上述public boolean offerLast(Object o) } public E remove()作用：删除队列中第一个元素，并返回该元素的值，如果元素为null，将抛出异常(其实底层调用的是removeFirst()) 源码如下： public E remove() { return removeFirst();//移除队列第一个元素。removeFirst()源码分析详见上述：public E removeFirst() } public E poll()作用：删除队列中第一个元素，并返回该元素的值，如果元素为null，将返回null。 源码如下： public E poll() { return pollFirst();//删除第一个元素，并返回删除元素的值.pollFirst()源码分析详见上述public E pollFirst() } public E element()作用：获取第一个元素。如果没有将抛出异常 源码如下： public E element() { return getFirst();//getFirst()用于获取第一个元素， 源码详见上述： public E getFirst() } public E peek()作用：获取第一个元素，如果返回null. 源码如下： public E peek() { return peekFirst(); } public E peekFirst() { // elements[head] is null if deque empty return (E) elements[head]; } public void push(E e)作用：栈顶添加一个元素. 源码如下： public void push(E e) { addFirst(e);//在head索引前添加元素，并将head前移。源码分析详见上述：public void addFirst(E e) } public E pop()作用：栈顶添加一个元素. 源码如下： public E pop() { return removeFirst();//删除第一个元素，并返回删除元素的值。源码分析详见上述：public E removeFirst() } public int size()作用：获取队列中元素个数. 源码如下： public int size() { return (tail - head) &amp; (elements.length - 1); } 源码分析： 当tail在数组中的位置在head的后面(tail - head) &amp; (elements.length - 1) 等价于 (tail - head)。当tail在数组中的位置在head的前面(tail - head) &amp; (elements.length - 1) 等价于 elements - (tail - head)。 public boolean isEmpty()作用：判断队列是否为空。 源码如下： public boolean isEmpty() { return head == tail; } 源码分析： tail位置的元素一定为空，head和tail相等，也为空。 public Iterator iterator()作用：迭代器，从前往后迭代 源码如下： public Iterator&lt;E&gt; iterator() { return new DeqIterator(); } private class DeqIterator implements Iterator&lt;E&gt; { private int cursor = head; private int fence = tail; // 迭代终止索引，同时也为了检测并发修改。 private int lastRet = -1; // 最近的next()调用返回的索引。据此可以定位到需要删除元素的位置。 public boolean hasNext() { return cursor != fence; } public E next() { if (cursor == fence) throw new NoSuchElementException(); E result = elements[cursor]; // This check doesn't catch all possible comodifications, // but does catch the ones that corrupt traversal if (tail != fence || result == null) throw new ConcurrentModificationException(); lastRet = cursor; cursor = (cursor + 1) &amp; (elements.length - 1); // 游标位置加1 return result; } public void remove() { if (lastRet &lt; 0) throw new IllegalStateException(); if (delete(lastRet)) { // 如果将元素从右往左移，需要将游标减1。 cursor = (cursor - 1) &amp; (elements.length - 1); // 游标位置回退1。 fence = tail; // 重置阀值。 } lastRet = -1; } } 源码分析： ArrayDeque继承了Iterable接口，必须实现其中的iterator()，ArrayDeque实现从头往后遍历的迭代器iterator()，其中主要包含：hasNext()方法用于判定当前cursor是否还有下一个元素；next()方法来锁定下一个元素；以及remove()用于移除lastRet处的元素值。 public Iterator descendingIterator()作用：迭代器，从后向前迭代 源码如下： public Iterator&lt;E&gt; descendingIterator() { return new DescendingIterator(); } private class DescendingIterator implements Iterator&lt;E&gt; { private int cursor = tail; // 游标开始索引为tail private int fence = head; // 游标的阀值为head private int lastRet = -1; public boolean hasNext() { return cursor != fence; } public E next() { if (cursor == fence) throw new NoSuchElementException(); cursor = (cursor - 1) &amp; (elements.length - 1); // tail是下个添加元素的位置，所以要减1才是尾节点的索引。 E result = elements[cursor]; if (head != fence || result == null) throw new ConcurrentModificationException(); lastRet = cursor; return result; } public void remove() { if (lastRet &lt; 0) throw new IllegalStateException(); if (!delete(lastRet)) { // 如果从左往右移，需要将游标加1。 cursor = (cursor + 1) &amp; (elements.length - 1); fence = head; } lastRet = -1; } } 源码分析： DescendingIterator是从后往前的迭代器。其中主要包含：hasNext()方法用于判定当前cursor是否还有下一个元素；next()方法来锁定下一个元素；以及remove()用于移除lastRet处的元素值。 public boolean contains(Object o)作用：判断队列中是否存在钙元素。 源码如下： public boolean contains(Object o) { if (o == null) return false;//ArrayDeque不能存储null值 int mask = elements.length - 1; int i = head; Object x; while ( (x = elements[i]) != null) { if (o.equals(x)) return true; i = (i + 1) &amp; mask;//处理临界情况 } return false; } 源码分析： 同上述：public boolean removeFirstOccurrence(Object o),从前往后遍历，如果在数组中存在与o相同的元素，则返回true。否则，返回false。 public Object[] toArray()作用：转成数组。 源码如下： public Object[] toArray() { return copyElements(new Object[size()]); } private &lt;T&gt; T[] copyElements(T[] a) { if (head &lt; tail) {//将elements数组所有元素复制到从0索引开始的a数组中 System.arraycopy(elements, head, a, 0, size()); } else if (head &gt; tail) {//先复制从elements数组head~elements.length - 1处数组，然后将0 ~ tail - 1索引处元素复制到后面 int headPortionLen = elements.length - head; System.arraycopy(elements, head, a, 0, headPortionLen); System.arraycopy(elements, 0, a, headPortionLen, tail); } return a; } 源码分析： 把所有元素拷贝到新创建的Object数组上，所以对返回数组的修改不会影响该双端队列。 public T[] toArray(T[] a)作用：转成指定数组。 源码如下： public &lt;T&gt; T[] toArray(T[] a) { int size = size(); if (a.length &lt; size)//目标数组大小不够 a = (T[])java.lang.reflect.Array.newInstance( a.getClass().getComponentType(), size);//利用反射创建类型为T，大小为size的数组 copyElements(a);//拷贝所有元素到目标数组。源码详见上述：&gt;public Object[] toArray() if (a.length &gt; size) a[size] = null;//结束标识 return a; } 源码分析： a = (T[])java.lang.reflect.Array.newInstance(a.getClass().getComponentType(), size); public void clear()作用：清空队列。 源码如下： public void clear() { int h = head; int t = tail; if (h != t) { // 判空条件 head = tail = 0; int i = h; int mask = elements.length - 1; do { elements[i] = null;//清除元素 i = (i + 1) &amp; mask; } while (i != t); } } 源码分析： 从前往后将数组值置空值。 public ArrayDeque clone()作用：克隆(复制)一个新的队列。 源码如下： public ArrayDeque&lt;E&gt; clone() { try { @SuppressWarnings(\"unchecked\") ArrayDeque&lt;E&gt; result = (ArrayDeque&lt;E&gt;) super.clone(); //传入elements数组与数组长度返回一个新数组。 result.elements = Arrays.copyOf(elements, elements.length);//深度复制 return result; } catch (CloneNotSupportedException e) { throw new AssertionError(); } } 源码分析： ArrayDeque类实现了Cloneable接口，可以通过super调用父类Object的clone()，克隆后result指向ArrayDeque队列。 6.参考资料 死磕 java集合之ArrayDeque源码分析ArrayDeque类的使用详解 三：栈Stack 1、栈的理解 栈（Stack）是一种受限的线性数据结构，所谓受限是指栈只暴露栈顶和栈底的操作，其底层是由数组实现的。栈的特性是先进后出，类似于手枪压弹，原理示意图如下： 2、Stack的继承关系 3、被弃用的Stack 3.1 被弃用的原因 从继承关系中，我们可以看到Stack的基本方法与底层实现，由于Vector是动态数组接口，其底层的实现是数组，因此，Stack的底层实现也是数组，且继承了Vector的公共方法。 从前文（简析Vector类）我们知道，Vector类具有动态扩容和随机访问的特性，因此，继承了Vector类的Stack也同样具有这些特性，这恰好违背了Stack数据结构的设计原理，正因为如此，Java中的Stack一直被认为是糟糕的实现，官方也将Stack标志为“弃用”（deprecated）。 综上所述，导致Stack糟糕实现的原因是Stack与Vector类的关系出现了错误，不应该是继承关系（is-a），而应是组合关系（has-a）。 3.2 如何替代 官方推荐使用Deque（双端队列）接口来实现Stack： Deque&lt;E&gt; stack = new ArrayDeque&lt;&gt;(); 虽然官方做出了推荐，但是我们仍然可以发现，Deque实现的Stack实质是一个双端队列，可以在队列的两端实现插入和删除操作，仍然破坏力了封装性，并不安全，可以看出这并不是一个完美的方法。 因此，在实际中更推荐大家再做一层封装，通过逻辑限定为只能一端操作插入和删除，形成一个真正的栈。 3.3 队列实现栈 用队列实现栈，只需要⼀个队列作为底层数据结构。 要实现的栈的API如下： class MyStack { /** 添加元素到栈顶 */ public void push(int x); /** 删除栈顶的元素并返回 */ public int pop(); /** 返回栈顶元素 */ public int top(); /** 判断栈是否为空 */ public boolean empty();} 先说 push API，直接将元素加⼊队列，同时记录队尾元素，因为队尾元素相当于栈顶元素，如果要 top 查 看栈顶元素的话可以直接返回： class MyStack { Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); int top_elem = 0; /** 添加元素到栈顶 */ public void push(int x) { // x 是队列的队尾，是栈的栈顶 q.offer(x); top_elem = x; } /** 返回栈顶元素 */ public int top() { return top_elem; }} 我们的底层数据结构是先进先出的队列，每次 pop 只能从队头取元素；但是栈是后进先出，也就是说 pop API 要从队尾取元素： 解决⽅法简单粗暴，把队列前⾯的都取出来再加⼊队尾，让之前的队尾元素排到队头，这样就可以取出了： /** 删除栈顶的元素并返回 */public int pop() { int size = q.size(); while (size &gt; 1) { size--; } // 之前的队尾元素已经到了队头 return q.poll();} 这样实现还有⼀点⼩问题就是，原来的队尾元素被提到队头并删除了，但是 top_elem 变量没有更新，我们 还需要⼀点⼩修改： /** 删除栈顶的元素并返回 */public int pop() { int size = q.size(); // 留下队尾 2 个元素 while (size &gt; 2) { q.offer(q.poll()); size--; } // 记录新的队尾元素 top_elem = q.peek(); q.offer(q.poll()); // 删除之前的队尾元素 return q.poll();} 最后，API empty 就很容易实现了，只要看底层的队列是否为空即可： /** 判断栈是否为空 */public boolean empty() { return q.isEmpty();} 很明显，⽤队列实现栈的话，pop 操作时间复杂度是 O(N)，其他操作都是 O(1) 。 3.4 面试中的Stack 如果面试中关注的是算法和程序的逻辑，那么数据结构的使用就不是重点，但是如果能用Deque实现，那自然是更好，尤其是需要考察对Java原因的理解。 ","link":"https://RenzoWang.github.io/Notes.github.io/post/dui-lie-queue-ji-shi-xian/"},{"title":"Java开发","content":" Java日常开发记录 ","link":"https://RenzoWang.github.io/Notes.github.io/post/java-kai-fa/"},{"title":"Error [Makefile] make: \"*\" is up to date","content":"原因：Makefile的目标target和当前目录下的某个文件名字冲突 解决方法： 比如是pstree这个名字冲突了 在Makefile中在pstree： .PHONY:pstree 即可 这里是用来让系统不要认为clean是一个文件（因为输入语句后会检测同级目录下有没有同名文件），用.PHONY意思是不是文件 ","link":"https://RenzoWang.github.io/Notes.github.io/post/error-makefile-make-is-up-to-date/"},{"title":"top-level const & low-level const","content":"top-level const &amp; low-level const top-level const to indicate that the pointer itself is a const. When a pointer can point to a const object, we refer tothat const as a low-level const. 一般的变量来说，其实没有顶层const和底层const的区别 1.一个指针本身添加const限定符就是顶层const。（指针被限定则 顶） 2.而指针所指的对象添加const限定符就是底层const。（对象被限则 底） 执行对象拷贝时有限制，常量的底层const不能赋值给非常量的底层const。 int num_c = 3; const int *p_c = &amp;num_c; //p_c为底层const的指针 还有一点记住 就是不能通过p_c去修改变量的值 //int *p_d = p_c; //错误，不能将底层const指针赋值给非底层const指针 const int *p_d = p_c; //正确，可以将底层const指针复制给底层const指针 使用命名的强制类型转换函数const_cast时，需要能够分辨底层const和顶层const，因为const_cast只能改变运算对象的底层const int num_e = 4; const int *p_e = &amp;num_e; //*p_e = 5; //错误，不能改变底层const指针指向的内容 int *p_f = const_cast&lt;int *&gt;(p_e); //正确，const_cast可以改变运算对象的底层const。但是使用时一定要知道num_e不是const的类型。 *p_f = 5; //正确，非顶层const指针可以改变指向的内容 cout &lt;&lt; num_e; //输出5 ","link":"https://RenzoWang.github.io/Notes.github.io/post/top-level-const-and-low-level-const/"},{"title":"Android Project","content":"A lite project for IM Chat App Here is the code ","link":"https://RenzoWang.github.io/Notes.github.io/post/android-project/"},{"title":"for vs. while in C programming","content":"There are three loops in C: for, while, and do-while. What's the difference between them? Answer A while loop will always evaluate the condition first. while (condition) { //gets executed after condition is checked } A do/while loop will always execute the code in the do{} block first and then evaluate the condition. do { //gets executed at least once } while A for loop allows you to initiate a counter variable, a check condition, and a way to increment your counter all in one line. for (int x = 0; x &lt; 100; x++) { //executed until x &gt;= 100 } More details can be seen at the original answer, here I just cite some that are useful for myself. ","link":"https://RenzoWang.github.io/Notes.github.io/post/for-vs-while-in-c-programming/"},{"title":"Algorithms","content":"LeetCode 数组 26. 删除排序数组中的重复项 class Solution { public: int removeDuplicates(vector&lt;int&gt;&amp; nums) { int count = 0; int index = 0; if((nums.empty())|| (nums.size() == 0)) { std::cout &lt;&lt; &quot;nums is empty or NULL!&quot; &lt;&lt; std::endl; return 0; } for(int i = 1; i &lt; nums.size(); i++ ) { if(nums[i] == nums[index]) { count++; } else { nums[i-count] = nums[i]; index++; } } return nums.size() - count; } }; 48.旋转图像 给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。 顺时针旋转90°： [1,2],[3,4] =&gt;[3,1],[4,2]; 其中可以看出： (i,j)顺时针旋转90°为(j,row-1-i); 若继续旋转90°为(row-1-i,col-1-j); 再顺时针旋转90°为(col-1-j,i); 可以知道将矩阵中的一个数给顺时针旋转90°，也就是将四个数互相交换位置 //其中row为行,col为列 swap(matrix[i][j],matrix[col-1-j][i]); swap(matrix[col-1-j][i],matrix[row-1-i][col-1-j]); swap(matrix[row-1-i][col-1-j],matrix[j][row-1-i]); ``` ```cpp class Solution { public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { for(size_t i = 0;i&lt;(matrix.size()+1)/2;++i) { for(size_t j =i;j&lt;matrix.size()-i-1;++j) { swap(matrix[i][j], matrix[matrix.size()-1-j][i]); swap(matrix[matrix.size()-1-j][i], matrix[matrix.size()-1-i][matrix.size()-1-j]); swap(matrix[matrix.size()-1-i][matrix.size()-1-j] ,matrix[j][matrix.size()-1-i]); } } } }; 66.加一 class Solution { public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) { int length = digits.size(); for(int i=length-1; i&gt;=0; --i) { digits[i] +=1; //digits[i] =digits[i]%10; if(digits[i] == 10) { digits[i] = 0; } else { return digits; } } //if all digits are num 9, then the loop will not return the NUM,so The highest digit carries 1 digits.insert(digits.begin(),1); return digits; } }; 122. 买卖股票的最佳时机 II 贪心算法 class Solution { public: int maxProfit(vector&lt;int&gt;&amp; prices) { int profit = 0; int data = prices.size(); if(prices.empty() || (data== 0)){ std::cout &lt;&lt; &quot;Parameters Invalid&quot; &lt;&lt; std::endl; } for(int i=1; i &lt; data; ++i) { profit += max(0, prices[i] - prices[i-1]); } return profit; } }; ** &quot;i++&quot; 与“++i”的区别** i++ 与 ++i 的主要区别有两个：根本区别是语义上的区别 a.) i++ 返回原来的值，++i 返回加1后的值。 **b.) ** i++ 不能作为左值，而++i 可以。 如果没有用到返回值的话，区别在于效率。 若i是内置的数值类型，两者完全一样 若i是一些自定义的类，如iterator，++i的效率 &gt; = i++的效率 136.只出现一次的数字 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 class Solution { public: int singleNumber(vector&lt;int&gt;&amp; nums) { int repeat = 0; for(int i = 0; i&lt; nums.size(); ++i) { repeat ^= nums[i]; } return repeat; } }; 189.旋转数组 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 class Solution { public: void rotate(vector&lt;int&gt;&amp; nums, int k) { int length = nums.size(); vector&lt;int&gt; temp(length); k = k % length; // Determine whether *k* exceeds the length of array if(nums.empty() || (nums.size()==0)){ std::cout &lt;&lt; &quot;Invalid Parameter&quot; &lt;&lt; std::endl; } for (int i = 0; i &lt; nums.size(); i++) { temp[i] = nums[i]; } for(int i = 0; i &lt; k; ++i) { nums[i] = temp [length-k+i]; } for(int j= k; j &lt; nums.size(); ++j) { nums[j] = temp[j-k]; } } }; 217. 存在重复元素 给定一个整数数组，判断是否存在重复元素。 如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。 class Solution { public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) { if(nums.empty() || (nums.size()==0)){ std::cout &lt;&lt; &quot;Invalid Parameter&quot; &lt;&lt; std::endl; } sort(nums.begin(), nums.end()); for(int i = 0; i &lt; nums.size()-1; ++i) { if (nums[i] == nums[i+1]){ return true; } } return false; } }; 283. 移动零 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 class Solution { public: void moveZeroes(vector&lt;int&gt;&amp; nums) { int length = nums.size(); // vector&lt;int&gt; nums2(length); int index = 0; for(int i=0; i&lt;=length-1; i++) { if(nums[i] != 0) { nums[index] = nums[i]; index++; } } if((length -index) &gt; 0) { for(int i = index; i &lt;= length -1; i++) { nums[i] = 0; } } //nums = nums2; } }; 350. 两个数组的交集 II class Solution { public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { sort(nums1.begin(), nums1.end()); sort(nums2.begin(), nums2.end()); // Sort vector&lt;int&gt;target; for(vector&lt;int&gt;::iterator it1=nums1.begin(),it2=nums2.begin();it1!=nums1.end()&amp;&amp;it2!=nums2.end();) { if(*it1&lt;*it2 ) it1++; else if(*it1==*it2) { target.push_back(*it1); it1++; it2++; } else if(*it1&gt;*it2 ) it2++; } return target; } }; 字符串 344.反转字符串 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 对称交换 class Solution { public: void reverseString(vector&lt;char&gt;&amp; s) { int length = s.size(); for (int i = 0; i &lt; (length+1)/2; ++i) { swap(s[i],s[length-1-i]); } } }; 7.整数反转 class Solution { public: int reverse(int x) { int rev = 0; while(x != 0) { int pop = x %10; x /=10; if((rev &gt; INT_MAX/10)) { return 0; } if((rev &lt; INT_MIN/10)) { return 0; } rev = rev*10 +pop; } return rev; } }; 字符串中的第一个唯一字符 ","link":"https://RenzoWang.github.io/Notes.github.io/post/algorithms/"},{"title":"ML","content":"综述，机器学习的自学简单来说分为三个步骤 前期：知识储备包括数学知识，机器学习经典算法知识，编程技术（python）的掌握 中期：算法的代码实现 后期：实战水平提升 机器学习路径规划图 一、数学基础 很多人看到数学知识的时候就望而却步，数学是需要的，但是作为入门水平，对数学的要求没有那么的高。假设你上过大学的数学课（忘了也没事），需要的数学知识啃一啃还是基本能理解下来的。 1.1、数学内容 线性代数：矩阵/张量乘法、求逆，奇异值分解/特征值分解，行列式，范数等 统计与概率：概率分布，独立性与贝叶斯，最大似然(MLE)和最大后验估计(MAP)等 优化：线性优化，非线性优化(凸优化/非凸优化)以及其衍生的如梯度下降、牛顿法等 微积分：偏微分，链式法则，矩阵求导等 信息论、数值理论等 上面的看不太懂没事，不是特别难，学习一下就能理解了。 1.2、数学资源 网上有很多人会列举大量大量的课程资源，这是非常不负责任的事，学完那些我头发都得白了。实际上，我们只需要学习其中的一部分就够了。 1.2.1、吴恩达的斯坦福大学机器学习王牌课程CS229，课后就有对学生数学知识的要求和补充，这些数学知识是完全符合机器学习要求的，不多也不少。墙裂推荐要看，不过只有英文版的。 链接：https://pan.baidu.com/s/1NrCAW38C9lXFqPwqTlrVRA 密码：3k3m 1.2.2、深度学习的三大开山鼻祖之一Yoshua Bengio写的深度学习（包含了机器学习）领域的教科书，现在以开源的形式在网上公开。这部书被誉为深度学习的圣经。在这里我们只看这本书的第一部分，也就是数学基础。囊括了机器学习所需的所有必备数学基础，而且是从最基础的说起，也不多，必读的。 链接：https://pan.baidu.com/s/1GmmbqFewyCuEA7blXNC-7g 密码：6qqm 1.2.3、跟机器学习算法相结合的数学知识。上面两部分是理论层面的数学，机器学习算法中会对这些数学进行应用。 链接：https://zhuanlan.zhihu.com/p/25197792，知乎专栏上的一篇好文章，囊括了所有的应用知识点。 好了，数学方面我只推荐上面三个资源，三个都是必看的。里面很多可能你现在看不太懂，没关系。先大概过一遍，知道自己的数学水平在哪。在看到算法知识的时候，不懂的再回来补就好。后期需要更多的数学资料我会再更新的。 二、编程技术 编程语言：python3.5及以上，python易学，这个这期先不细讲。 三、经典算法知识 算法包括机器学习和深度学习，机器学习是深度学习的基础。所以务必先学机器学习的经典算法，再学深度学习的算法。 3.1、机器学习 3.1.1、课程资料 首推吴恩达的CS229，经典中的经典，在网易公开课里有视频，翻译，课程讲义，笔记是非常非常完备的。墙裂推荐。这个课程对数学有一定的要求，但我觉得只要你上过大学的数学，然后补一下上面的数学，完全可以直接来看这个CS229。 假设你的数学真的很差的话，怎么办？吴恩达在coursera上也开了一门跟CS229完全匹配的课程，coursera机器学习课。这门课是CS229的翻版，唯一不同的是它对数学基本是没有要求了，如果你对数学真的不懂的话，那就先看这个的教程吧。它跟CS229的关系就是同样的广度，但是深度浅很多，不过你学完coursera还是要回过头来看CS229的。这个也是免费的。 CS229课程视频：http://open.163.com/special/opencourse/machinelearning.html 课程讲义和中文笔记：https://pan.baidu.com/s/1MC_yWjcz_m5YoZFNBcsRSQ 密码：6rw6 3.1.2、配套书籍： 机器学习实战，必看。用代码实现了一遍各大经典机器学习算法，必须看，对你理解算法有很大帮助，同时里面也有应用。如果大家看上面纯理论的部分太枯燥了，就可以来看看这本书来知道在现实中机器学习算法是怎么应用的，会很大程度提升你的学习兴趣，当初我可是看了好几遍。 书籍及课后代码：链接：https://pan.baidu.com/s/15XtFOH18si316076GLKYfg 密码：sawb 李航《统计学习方法》，配合着看 链接：https://pan.baidu.com/s/1Mk_O71k-H8GHeaivWbzM-Q 密码：adep，配合着看 周志华《机器学习》，机器学习的百科全书，配合着看。 链接：https://pan.baidu.com/s/1lJoQnWToonvBU6cYwjrRKg 密码：7rzl 3.2、深度学习 说到深度学习，我们不得不提斯坦福的另一门王牌课程CS231，李飞飞教授的。这门课的课程，课后习题，堪称完美。必须必须看。整个系列下来，特别是课后的习题要做，做完之后你会发现，哇哦！它的课后习题就是写代码来实现算法的。这个在网易云课堂上有。 视频地址：http://study.163.com/course/introduction.htm?courseId=1004697005 课程笔记翻译，知乎专栏：https://zhuanlan.zhihu.com/p/21930884 墙裂建议要阅读这个知乎专栏，关于怎么学这门课，这个专栏写的很清楚。 课后作业配套答案：https://blog.csdn.net/bigdatadigest/article/category/7425092 3.3、学习时间 到这里了，你的机器学习和深度学习算是入门了。学完上面这些，按一天6小时，一周六天的话，起码也得三个月吧。上面是基本功一定要认真学。但是，还找不了工作。因为你还没把这些知识应用到实际当中。 3.4、实战部分 3.4.1、实战基础 这一个阶段，你要开始用tensorflow（谷歌的深度学习框架）、scikit-learn（python的机器学习框架），这两个框架极大程度地集成了各大算法。其实上面在学习cs231n的时候你就会用到一部分。 scikit-learn的学习：http://sklearn.apachecn.org/cn/0.19.0/ 这是scikit-learn的官方文档中文版翻译，有理论有实战，最好的库学习资源，没有之一。认真看，传统的机器学习就是用这个库来实现的。 Tensorflow的学习：https://tensorflow.google.cn/api_docs/python/?hl=zh-cn 官方文档很详尽，还有实战例子，学习tensorflow的不二之选 3.4.2、实战进阶 仅仅看这两个教程是不够的，你需要更多地去应用这两个库。 接下来推荐一部神书，机器学习和深度学习的实战教学，非常非常的棒，网上有很多号称实战的书或者例子，我看了基本就是照搬官网的，只有这一本书，是完全按照工业界的流程解决方案进行实战，你不仅能学习到库的应用，还能深入了解工业界的流程解决方案，最好的实战教学书，没有之一。书名是hands-on-ml-with-sklearn-and-tf 链接：https://pan.baidu.com/s/1x318qTHGt9oZKQwHkoUvKA 密码：xssj 3.4.3、实战最终阶段 kaggle数据竞赛，如果你已经学到了这一步，恭喜你离梦想越来越近了：对于我们初学者来说，没有机会接触到机器学习真正的应用项目，所以一些比赛平台是我们不错的选择。参加kaggle竞赛可以给你的简历增分不少，里面有入门级别到专家级别的实战案例，满足你的各方面需求。如果你能学到这一步了，我相信也不需要再看这个了。 上述所有资料的合集：https://pan.baidu.com/s/1tPqsSmSMZa6qLyD0ng87IQ 密码：ve75 补充： 学到这个水平，应该是能够实习的水平了，还有很多后面再说吧。比如深度学习和机器学习的就业方向，深度学习得看论文，找工作还得对你得编程基础进行加强，具体就是数据结构与算法，我当年在这个上面可是吃了很大的亏。 这里面关于深度学习和机器学习的就业其实是两个方向，上面的其实也没有说全。一般来说，你得选择一个方向专攻。我建议的是，自学的最好在后期侧重机器学习方向，而不是深度学习。深度学习的岗位实在是太少，要求太高。机器学习还算稍微好点。 重点：上面的学习路径是主要框架，但是不意味着仅仅学习这些就够了。根据每个人基础的不同，你有可能需要另外的学习资料补充。但是，我希望大家可以按照上面的主框架走，先按上面我推荐的资源学，有需要的再去看别的（我之后也会推荐），上面的我能列出来的都是最经典的，最有效率，而且我亲身学过的。 后续文章： 上面每个学习步骤还可以细分开来，这是接下来文章的重点。比如python怎么学，cs229和cs231学习过程中会碰到什么困难，kaggle怎么用，数学还跟不上怎么办？后续都会一一说明。 欢迎转载，但请注明出处，尊重作者，谢谢大家了！ 原文博主微信公众号：learningthem 更多干货，会继续分享 作者：q7695650 来源：CSDN 原文：https://blog.csdn.net/q7695650/article/details/81331328 版权声明：本文为博主原创文章，转载请附上博文链接！ ","link":"https://RenzoWang.github.io/Notes.github.io/post/ml/"},{"title":"SQL ","content":"SQL简介 SQL是用于访问和处理数据库的标准的计算机语言，全称为Structured Query Language，可以访问和处理数据库。 是一种 ANSI（American National Standards Institute 美国国家标准化组织标准的计算机语言。 虽然 SQL 是一门 ANSI（American National Standards Institute 美国国家标准化组织）标准的计算机语言，但是仍然存在着多种不同版本的 SQL 语言。 然而，为了与 ANSI 标准相兼容，它们必须以相似的方式共同地来支持一些主要的命令（比如 SELECT、UPDATE、DELETE、INSERT、WHERE 等等）。 除了 SQL 标准之外，大部分 SQL 数据库程序都拥有它们自己的专有扩展！ DBMS DBMS : A database-management system (DBMS) is a collection of interrelated data and a set of programs to access those data. The collection of data, usually referred to as the database DBMS 中的数据存储在被称为表的数据库对象中。 表是相关的数据项的集合，它由列和行组成。 SQL 语法 SQL 对大小写不敏感：即SELECT与select是相通的 某些数据库系统要求在每条 SQL 语句的末端使用分号。 分号是在数据库系统中分隔每条 SQL 语句的标准方法，这样就可以在对服务器的相同请求中执行一条以上的 SQL 语句。 SELECT - 从数据库中提取数据 UPDATE - 更新数据库中的数据 DELETE - 从数据库中删除数据 INSERT INTO - 向数据库中插入新数据 CREATE DATABASE - 创建新数据库 ALTER DATABASE - 修改数据库 CREATE TABLE - 创建新表 ALTER TABLE - 变更（改变）数据库表 DROP TABLE - 删除表 CREATE INDEX - 创建索引（搜索键） DROP INDEX - 删除索引 select 语句 SELECT 语句用于从数据库中选取数据。结果被存储在一个结果表中，称为结果集。 SELECT DISTINCT 语句 在表中，一个列可能会包含多个重复值，有时您也许希望仅仅列出不同（distinct）的值。 DISTINCT 关键词用于返回唯一不同的值。 SELECT DISTINCT column_name,column_name FROM table_name; ","link":"https://RenzoWang.github.io/Notes.github.io/post/eclt5840-sql/"},{"title":"Linux添加网卡","content":"Debian/Ubuntu系列 方法一： sudo ifconfig eth0:0 192.168.1.63 up eth0网卡上创建一个叫eth0:0的虚拟网卡,他的地址是:192.168.1.63 如果不想要这个虚拟网卡了,可以使用如下命令删除: sudo ifconfig eth0:0 down 方法二： sudo vim /etc/network/interfaces 添加并保存例如以下内容： auto ens33:0 iface ens33:0 inet static address 10.60.0.1 netmask 255.0.0.0 network 192.168.1.1 broadcast 192.168.1.255 重启网卡生效 sudo /etc/init.d/networking restart ","link":"https://RenzoWang.github.io/Notes.github.io/post/linux-tian-jia-wang-qia/"},{"title":"TC(Traffic Control)","content":" Linux中的流量控制 1. TC原理 Linux操作系统中的流量控制器TC（Traffic Control）用于Linux内核的流量控制，主要是通过在输出端口处建立一个队列来实现流量控制。 接收包从输入接口进来后，经过流量限制丢弃不符合规定的数据包，由输入多路分配器进行判断选择： 如果接收包的目的主机是本主机，那么将该包送给上层处理，否则需要进行转发，将接收包交到转发块（Forwarding Block）处理。 转发块同时也接收本主机上层(TCP、UDP等)产生的包，通过查看路由表，决定所处理包的下一跳。 然后，对包进行排列以便将它们送到输出接口。 一般只能限制网卡发送的数据包，不能限制网卡接收的数据包，所以可以通过改变发送次序来控制传输速率。Linux流量控制主要是在输出接口排列时进行处理和实现的。 2. 规则 2.1 队列（Queues） 和排队规则（Queueing Disciplines） 通过对包进行排队（queuing），我们可以决定数据的发送方式（the way in which data is SENT）。但理解下面这一点非常重要：我们只能对发送（transmit）的数据进行整形（shape the data）。 互联网的工作机制决定了接收端无法直接控制发送端的行为。这就像你家的 （实体！）邮箱一样：除非能联系到所有人（告诉他们未经同意不要寄信给你），否则 你无法控制别人寄多少东西过来。😉 但与实际生活不同的是，互联网基于 TCP/IP 协议栈，这多少会带来一些帮助。TCP/IP 无法提前知道两台主机之间的网络带宽，因此开始时它会以越来越快的速度发送数据（慢启 动），直到开始出现丢包，这时它知道已经没有可用空间来存储这些待发送的包了，因此就会 降低发送速度。TCP/IP 的实际工作过程比这个更智能一点，我们后面会再讨论。 这就好比你留下一半的信件在实体邮箱里不取，期望别人知道这个状况后会停止给你寄新的信件。 但不幸的是，这种方式只对互联网管用，对你的实体邮箱无效 😃 如果内网有一台路由器，你希望限制某几台主机的下载速度，那你应该找到发送数据到 这些主机的路由器内部接口（inner interface of your router），然后在这些 路由器内部接口上做 整流（traffic shaping，流量整形）。 此外，还要确保链路瓶颈（bottleneck of the link）也在你的控制范围内。例如，如果网 卡是 100Mbps，但路由器的链路带宽是 256Kbps，那首先应该确保不要发送过多数据给路由器，因为它可能扛不住。否则，链路控制和带宽整形的决定权就不在主机侧而到路由器侧了。要达到限速目的，我们需要对“发送队列”有完全的把控（”own the queue”），这里的“发送队列”也就是整条链路上最慢的一段（slowest link in the chain）。 幸运的是，大多数情况下这个条件都是能满足的。 2.2 Simple， classless qdisc（简单、不分类排队规则） 如前所述，排队规则（queueing disciplines）改变了数据的发送方式。 不分类（或称无类别）排队规则（classless queueing disciplines）可以对某个网络 接口（interface）上的所有流量进行无差别整形。包括对数据进行： 重新调度（reschedule） 增加延迟（delay） 丢弃（drop） 与 classless qdisc 对应的是 classful qdisc，即有类别（或称分类别）排队规则，后者是一个排队规则中又包含其他排队规则（qdisc-containing-qdiscs）！😮 先理解了 classless qdisc，才能理解 classful qdisc。 目前最常用的 classless qdisc 是 pfifo_fast qdisc，这也是默认排队规则。 这也解释了为什么这些高级功能如此健壮：本质上来说，它们只不过是“另一个队列”而 已（nothing more than ‘just another queue’）。 每种队列都有自己的优缺点。其中一些可能测试的并不全面。 2.2.1 pfifo_fast（先入先出队列） 如名字所示，这是一个先入先出队列（First In, First Out），因此对所有包都一视同仁。 pfifo_fast 有三个所谓的 “band”（可理解为三个队列），编号分别为 0、1、2： 每个 band 上分别执行 FIFO 规则。 如果 band 0 有数据，就不会处理 band 1；同理，band 1 有数据时， 不会去处理 band 2。 内核会检查数据包的 TOS 字段，将**“最小延迟”的包放到 band 0**。 不要将 pfifo_fast qdisc 与后面介绍的 PRIO qdisc 混淆，后者是 classful 的！ 虽然二者行为类似，但 pfifo_fast 是无类别的，这意味你无法通过 tc 命令向 pfifo_fast 内添加另一个 qdisc。 2.2.1.1 参数与用法 pfifo_fast qdisc 默认配置是写死的（the hardwired default），因此无法更改。 下面介绍这份写死的配置是什么样的。 priomap priomap 决定了如何将内核设置的 packet priority 映射到 band。priority 位于包的 TOS 字段： 0 1 2 3 4 5 6 7 +-----+-----+-----+-----+-----+-----+-----+-----+ | | | | | PRECEDENCE | TOS | MBZ | | | | | +-----+-----+-----+-----+-----+-----+-----+-----+s TOS 字段占用 4 个比特，各 bit 含义如下： Binary Decimcal Meaning ----------------------------------------- 1000 8 Minimize delay (md) 0100 4 Maximize throughput (mt) 0010 2 Maximize reliability (mr) 0001 1 Minimize monetary cost (mmc) 0000 0 Normal Service tcpdump -vv 会打印包的 TOS 字段，其中的 TOS 值对应下面的第一列： TOS Bits Means Linux Priority Band ------------------------------------------------------------ 0x0 0 Normal Service 0 Best Effort 1 0x2 1 Minimize Monetary Cost 1 Filler 2 0x4 2 Maximize Reliability 0 Best Effort 1 0x6 3 mmc+mr 0 Best Effort 1 0x8 4 Maximize Throughput 2 Bulk 2 0xa 5 mmc+mt 2 Bulk 2 0xc 6 mr+mt 2 Bulk 2 0xe 7 mmc+mr+mt 2 Bulk 2 0x10 8 Minimize Delay 6 Interactive 0 0x12 9 mmc+md 6 Interactive 0 0x14 10 mr+md 6 Interactive 0 0x16 11 mmc+mr+md 6 Interactive 0 0x18 12 mt+md 4 Int. Bulk 1 0x1a 13 mmc+mt+md 4 Int. Bulk 1 0x1c 14 mr+mt+md 4 Int. Bulk 1 0x1e 15 mmc+mr+mt+md 4 Int. Bulk 1 第二列是对应的十进制表示，第三列是对应的含义。例如，15 表示这个包期望 Minimal Monetary Cost + Maximum Reliability + Maximum Throughput + Minimum Delay。我把这样的包称为“荷兰包”（a ‘Dutch Packet’。荷兰人比较 节俭/抠门，译注）。第四列是对应到 Linux 内核的优先级；最后一列是 映射到的 band，从命令行输出看，形式为： 1, 2, 2, 2, 1, 2, 0, 0 , 1, 1, 1, 1, 1, 1, 1, 1 例如，priority 4 会映射到 band 1。priomap 还能列出 priority &gt; 7 的那些 不是由 TOS 映射、而是由其他方式设置的优先级。例如，下表列出了应用（application）是如何设置它们的 TOS 字段的，来自 RFC 1349（更多信息可阅读全文) TELNET 1000 (minimize delay) FTP Control 1000 (minimize delay) Data 0100 (maximize throughput) TFTP 1000 (minimize delay) SMTP Command phase 1000 (minimize delay) DATA phase 0100 (maximize throughput) DNS UDP Query 1000 (minimize delay) TCP Query 0000 Zone Transfer 0100 (maximize throughput) NNTP 0001 (minimize monetary cost) ICMP Errors 0000 Requests 0000 (mostly) Responses &lt;same as request&gt; (mostly) txqueuelen 发送队列长度，是一个网络接口（interface）参数，可以用 ifconfig 命令设置。例 如，ifconfig eth0 txqueuelen 10。 tc 命令无法修改这个值。 2.2.2 TBF（Token Bucket Filter，令牌桶过滤器） TBF 是一个简单 qdisc，对于没有超过预设速率的流量直接透传，但也能容忍超过预 设速率的短时抖动（short bursts in excess of this rate）。 TBF 非常简洁，对网络和处理器都很友好（network- and processor friendly）。 如果只是想实现接口限速，那 TBF 是第一选择。 TBF 实现包括几部分： A buffer (bucket)：bucket 最重要的参数是它的大小，即能容纳的 token 数量。 Tokens：token 会以特定的速率（specific rate）填充 bucket 缓冲区。 当一个包到来时，会从 bucket 中拿到一个 token，然后收集这个包的信息，最后从 bucket 中删除这个 token。 这个算法和 token flow、data flow 结合起来，会产生三种可能的场景： 数据速率 == token 速率：每个包都能找到一个对应的token，然后直接从队列出去，没有延时（delay）。 数据速率 &lt; token 速率：正常到来的数据都能及时发送出去，然后删除一个 token。 由于 token 速率大于数据速率，会产生 bucket 积压，极端情况会将 bucket 占满。如果数据速率突然高于 token 速率，就可以消耗这些积压的 token 。因此积压的 token 有一个额外好处：能够容忍短时数据速率抖动（burst）。 数据速率 &gt; token 速率：token 很快就会用完，然后** TBF 会关闭（throttle ）一会**。这种 情况称为 overlimit（超过限制）。如果包还是源源不断地到来，就会产生丢包。 第三种非常重要，因为它使我们能够对数据可用的带宽进行整形（administratively shape the bandwidth）。 积压的 token 使得超过限速的短时抖动数据仍然能发送，不会丢包，但持续的 overload 会导致数据不断被 delay，然后被丢弃。 注意：在实际的实现中，token 是基于字节数，而不是包数。 2.2.2.1 参数与用法 虽然通常情况下并不需要修改 TBF 配置参数，但我们还是可以看一下有哪些。 首先，永远可用的（always available）参数： limit or latency limit：因等待可用 token 而被放入队列的字节数。 latency：每个包在 TBF 中停留的最长时间。随后会基于 latency、bucket size、rate 和 peakrate（如果设置了）来计算 limit。 burst/buffer/maxburst bucket 的大小，单位是字节。这是累积可用的 token 所支持的最大字节数（ maximum amount of bytes that tokens can be available for instantaneously）。总 体来说，越大的整流速率（shaping rates）需要越大的缓冲区。要在 Intel 网卡 上实现 10Mbps 整流，你至少需要 10KB 缓冲区。 如果缓冲区太小，可能会丢包，因为 token 到来太快导致无法放入 bucket 中。 mpu “零长度”的包占用的并不是零带宽（A zero-sized packet does not use zero bandwidth）。例如对于以太网，任何一个包的字节数不会少于 64。 Minimum Packet Unit（最小包单元）决定了一个包所使用的最小 token 量（the minimal token usage for a packet）。 rate 速度旋钮（speedknob）。 如果当前 bucket 中有 token，并且没有禁止 bucket 的 token 删除动作，那默认情况下 ，它会全速删除。如果不期望这种行为，那可以设置下面几个参数： peakrate 如前所述，默认情况下，包到了之后只要有 token 就会被立即发送。这可能不是你期 望的，尤其当 bucket 很大的时候。 peakratepeakratepeakrate 可指定 bucket 发送数据的最快速度。通常来说，这需要做的 就是：放行一个包 - 等待恰当的时长 - 放行下一个包。通过计算等待时长，最终实现 了 peakrate 效果。 但实际中，由于 Unix 默认的 10ms 定时器精读限制，如果平均每个包 10K bits ， 我们只能做到 1Mbps1Mbps1Mbps peakrate！（10Kb/10ms=1000Kbps=1Mbps10Kb/10ms = 1000Kbps = 1Mbps10Kb/10ms=1000Kbps=1Mbps，译注）。 mtu/minburst 1Mbit/s1Mbit/s1Mbit/s 的 peakrate 通常并不是很有用，因为实际中的带宽要远大于此。实现更高 peakrate 的一种方式是：每个 timer tick 发送多个包，在效果上就好像我们创建 了第二个 bucket！ 这第二个 bucket 默认只有一个包（defaults to a single packet），完全算不上一个 bucket。 计算最大可能的 peakrate 时，用 MTU 乘以 100（更准确地说，乘以 HZ 数，例如 Intel 上是 100，Alpha 上是 1024）。 2.2.2.2 示例配置 一个简单但非常有用的配置： $ tc qdisc add dev ppp0 root tbf rate 220kbit latency 50ms burst 1540 为什么说这个配置很有用呢？如果你有一个 queue 很大的网络设备，例如 DSL modem 或 cable modem，而且用一个快速设备（例如以太网接口）连接到这个网络设备，那你会发现 大文件上传会严重影响实时交互。 这是因为上传的数据会被缓存到 modem 的 queue 里，而且缓存的数据量很大（以提升吞吐） 。但这并不是期望的，你希望的是 queue 不要太大，这样能保证交换式数据的实时性，因 此能在上传数据过程中同时做其他事情。 上面的配置将发送速率降低到了 modem 不会对数据进行排队缓存（queuing）的水平 —— 此时 queue 前移到了 Linux 中，而我们可以将它控制在一个合理的范围内。 这里的 220kbit 是上行链路的真实带宽乘以一个系数，如果你的 modem 足 够快，可以将 burst 调大一些。 2.2.3 SFQ（Stochastic Fairness Queueing，随机公平排队） 随机公平排队（SFQ）是公平排队算法族的一个简单实现。相比其他算法，SFQ 精准性要差 一些，但它所需的计算量也更少，而结果几乎是完全公平的（almost perfectly fair）。 SFQ 中的核心是 conversion（会话）或 flow（流），大部分情况下都对应一个 TCP session 或 UDP stream。每个 conversion 对应一个 FIFO queue，然后将流量分到不 同 queue。发送数据时，按照 round-robin 方式，每个 session 轮流发送。 这种机制会产生非常公平的结果，不会因为单个 conversion 太大而把其他 conversion 的带宽都 挤占掉。SFQ 被称为**“随机的”（stochastic）是因为它其实并没有为每个 session 分配一个 queue**，而是用算法将流量哈希到了一组有限的 queue。 但这里会出现另一个问题：多个 session 会可能会哈希到同一个 bucket（哈希槽）， 进而导致每个 session 的 quota 变小，达不到预期的整流带宽（或速度）。为避免这个 问题过于明显，SFQ 会不断变换它使用的哈希算法，最终任何两个会话冲突的持续时间都不会很长，只会有几秒钟。 SFQ 只有在实际出向带宽已经非常饱和的情况下才有效，这一点非常重要！否则， Linux 机器上就不存在 queue，因此也就没用效果。稍后会看到如何将 SFQ 与其他 qdisc 相结合来实现一般情况下的公平排队。 说的更明确一点：没用配套的整流配置的话，单纯在（连接 modem 的）以太网接口上配 置SFQ 是毫无意义的。 2.2.3.1 参数与用法 SFQ 大部分情况下默认参数就够了， -perturb 每隔多少秒就重新配置哈希算法。如果这个参数没设，哈希算法就永远不会重新配置。 建议显式设置这个参数，不要为空。10s 可能是个不错的选择。 -quantum 在轮到下一个 queue 发送之前，当前 queue 允许出队（dequeue）的最大字节数。默认是 一个 MTU。不建议设置为小于 MTU 的值。 -limit SFQ 能缓存的最大包数（超过这个阈值将导致丢包）。 2.2.3.2 示例配置 如果你有一个带宽已经饱和的网络设备，例如一个电话调制解调器（phone modem），那下 面的配置有助于提高公平性： $ tc qdisc add dev ppp0 root sfq perturb 10 $ tc -s -d qdisc ls qdisc sfq 800c: dev ppp0 quantum 1514b limit 128p flows 128/1024 perturb 10sec Sent 4812 bytes 62 pkts (dropped 0, overlimits 0) 解释： - 800c:：自动分配的 handle number（句柄编号） -limit 128p：最大缓存 128 个包 -flows 128/1024：这个 sfq 有 1024 个哈希槽（hash buckets），其中 128 个当前有 数据待发送。 -perturb 10sec：每隔 10s 换一次哈希算法。 2.3 使用建议：何时选择哪种队列？ 总结起来，上面几种都是简单的 qdisc，通过重排序（reordering）、降速（slowing）或 丢包（dropping）来实现流量管理。 选择使用哪种 qdisc 时，下面几点可供参考。其中提到了几种在第 14 章才会介绍到的 qdisc。 -单纯对出向流量限速（slow down outgoing traffic），推荐使用** TBF**。如果是 针对大带宽进行限速，需要将 bucket 调大。 如果带宽已经打满，想确保带宽没有被任何单个 session 占据，推荐使用 SFQ。 If you have a big backbone and know what you are doing, consider Random Early Drop (see Advanced chapter). 对（不再转发的）入向流量整形，使用 Ingress Policer。顺便说一句，入向整形称为 ‘policing’，而不是 ‘shaping’。 对需要本机转发的流量整形， 如果目的端是单个设备，那在目的端设备上使用 TBF。 如果目的端是多个设备（同一个入向设备分流到多个目的设备），使用 Ingress Policer。 如果你不需要整形，只是想看看网络接口（interface）是否过载（so loaded that it has to queue）， 使用 pfifo queue（注意不是 pfifo_fast）。pfifo 内部没有 bands，但会记录 backlog 的大小。 最后 —— 你还可以尝试“社会学整形”（”social shaping”）。有时候一些问题是无法单纯 用技术解决的。用户会对技术限制充满敌意。和气地对别人说几句好话，也许你需要的 带宽就解决了。 2.4 术语 为方便理解接下来更复杂的配置，我们需要先引入一些概念。由于这项技术本身比较复杂， 发展也还处在较为早期的阶段，因此大家可能会用不同的术语描述同一样东西。 下列术语大体上来自 draft-ietf-diffserv-model-06.txt, An Informal Management Model for Diffserv Routers。想进一步了解一些术语的定义，可参考这份文档。 我们接下来会用到下列术语： Queueing Discipline (qdisc，排队规则) 管理设备队列（queues of devices）的算法，可以是管理入向（incoing/ingress ）队列，也可以是管理出向队列（outgoing/egress）。 root qdisc（根排队规则） attach 到网络设备的那个 qdisc。 Classless qdisc（无类别排队规则） 对所有包一视同仁，同等对待。 Classful qdisc（有类别排队规则） 一个 classful qdisc 会包含多个类别（classes）。每个类别（class）可以进一步包 含其他 qdisc，可以是 classful qdisc，也可以是 classless qdisc。 严格按定义来说，pfifo_fast 属于有类别排队规则（classful），因为它内部包 含了三个 band，而这些 band 实际上是 class。但从用户配置的视角来说，它是 classless 的，因为这三个内部 class 用户是无法通过 tc 命令配置的。 Classes（类别） 每个 classful qdisc 可能会包含几个 class，这些都是 qdisc 内部可见的。对于每 个 class，也是可以再向其添加其他 class 的。因此，一个 class 的 parent 可以 是一个 qdisc，也可以是另一个 class。 Leaf class 是没有 child class 的 class。这种 class 中 attach 了一个 qdisc ，负责该 class 的数据发送。 创建一个 class 时会自动 attach 一个 fifo qdisc。而当向这个 class 添加 child class 时，这个 fifo qdisc 会被自动删除。对于 leaf class，可以用一个更合适的 qdisc 来替换掉这个fifo qdisc。你甚至能用一个 classful qdisc 来替换这个 fifo qdisc，这样就可以添加其他 class了。 Classifier（分类器） 每个 classful qdisc 需要判断每个包应该放到哪个 class。这是通过分类器完成的。 Filter（过滤器） 分类过程（Classification）可以通过过滤器（filters）完成。过滤器包含许多的判 断条件，匹配到条件之后就算 filter 匹配成功了。 Scheduling（调度） 在分类器的协助下，一个 qdisc 可以判断某些包是不是要先于其他包发送出去，这 个过程称为调度，可以通过例如前面提到的 pfifo_fast qdisc 完成。调度也被 称为重排序（reordering），但后者容易引起混淆。 Shaping（整形） 在包发送出去之前进行延迟处理，以达到预设的最大发送速率的过程。整形是在 egress 做的（前面提到了，ingress 方向的不叫 shaping，叫 policing，译者注）。 不严格地说，丢弃包来降低流量的过程有时也称为整形。 Policing（执行策略，决定是否丢弃包） 延迟或丢弃（delaying or dropping）包来达到预设带宽的过程。 在 Linux 上， policing 只能对包进行丢弃，不能延迟 —— 没有“入向队列”（”ingress queue”）。 Work-Conserving qdisc（随到随发 qdisc） work-conserving qdisc 只要有包可发送就立即发送。换句话说，只要网卡处于可 发送状态（对于 egress qdisc 来说），它永远不会延迟包的发送。 non-Work-Conserving qdisc（非随到随发 qdisc） 某些 qdisc，例如 TBF，可能会延迟一段时间再将一个包发送出去，以达到期望的带宽 。这意味着它们有时即使有能力发送，也不会发送。 有了以上概念，我们来看它们都是在哪里用到的。 Userspace programs ^ | +---------------+-----------------------------------------+ | Y | | -------&gt; IP Stack | | | | | | | Y | | | Y | | ^ | | | | / ----------&gt; Forwarding -&gt; | | ^ / | | | |/ Y | | | | | | ^ Y /-qdisc1-\\ | | | Egress /--qdisc2--\\ | ---&gt;-&gt;Ingress Classifier ---qdisc3---- | -&gt; | Qdisc \\__qdisc4__/ | | \\-qdiscN_/ | | | +----------------------------------------------------------+ Thanks to Jamal Hadi Salim for this ASCII representation. 上图中的框代表 Linux 内核。最左侧的箭头表示流量从外部网络进入主机。然后进入 Ingress Qdisc，这里会对包进行过滤（apply Filters），根据结果决定是否要丢弃这个包。这个过程称为 “Policing”。这个过程发生在内核处理的很早阶段，在穿过大部 分内核基础设施之前。因此在这里丢弃包是很高效的，不会消耗大量 CPU。 如果判断允许这个包通过，那它的目的端可能是本机上的应用（local application），这 种情况下它会进入内核 IP 协议栈进行进一步处理，最后交给相应的用户态程序。另外，这 个包的目的地也可能是其他主机上的应用，这种情况下就需要通过这台机器 Egress Classifier 再发送出去。主机程序也可能会发送数据，这种情况下也会通过 Egress Classifier 发送。 Egress Classifier 中会用到很多 qdisc。默认情况下只有一个：pfifo_fast qdisc ，它永远会接收包，这称为“入队”（”enqueueing”）。 此时包位于 qdisc 中了，等待内核召唤，然后通过网络接口（network interface）发送出去。 这称为“出队”（”dequeueing”）。 以上画的是单网卡的情况。在多网卡的情况下，每个网卡都有自己的 ingress 和 egress hooks。 2.5 Classful qdisc（分类别排队规则） 如果想对不同类型的流量做不同处理，那 classful qdisc 非常有用。其中一种是 CBQ（ Class Based Queueing，基于类别的排队），由于这种类型的 qdisc 使用太广泛了，导致 大家将广义上基于类别的排队等同于 CBQ（identify queueing with classes solely with CBQ），但实际并非如此。 CBQ 只是其中最古老 —— 也是最复杂 —— 的一种。它的行为有时可能在你的意料之外。 那些钟爱 “sendmail effect” 的人可能感到震惊。 sendmail effect：对于任何复杂的技术，没有文档的实现一定是最好的实现。 Any complex technology which doesn’t come with documentation must be the best available. 接下来介绍更多关于 CBQ 及其类似 qdisc 的信息。 2.5.1 Classful qdisc &amp; class 中的 flow 当流量进入一个 classful qdisc 时，该 qdisc 需要将其发送到内部的某个 class —— 即 需要对这个包进行“分类”。而要这个判断过程，，实际上是查询所谓的“过滤器”（ ‘filters’）。过滤器是在 qdisc 中被调用的，而不是其他地方，理解一点非常重要！ 过滤器返回一个判决结果给 qdisc，qdisc 据此将包 enqueue 到合适的 class。 每个 subclass 可能会进一步执行其他 filters，以判断是否需要进一步处理。如果没有 其他过滤器，这个 class 将把包 enqueue 到它自带的 qdisc。 除了能包含其他 qdisc，大部分 classful qdisc 还会执行流量整形。这对包调 度（packet scheduling，例如，基于 SFQ）和速率控制（rate control）都非常有用。 当高速设备（例如，以太网）连接到一个低速设备（例如一个调制解调器）时，会用到这个 功能。 如果只运行 SFQ，那将什么事情都不会发生，因为包会无延迟地进入和离开你的路由 器：网卡的发送速度要远大于真实的链路速度。瓶颈不在主机中，就无法用“队列”（queue ）来调度这些流量。 2.5.2 qdisc 大家庭：roots, handles, siblings and parents 每个接口都有一个 egress “root qdisc”。默认情况下，这个 root qdisc 就是前 面提到的 classless pfifo_fast qdisc。 每个 qdisc 和 class 都会分配一个相应的 handle（句柄），可以指定 handle 对 qdisc 进行配置。 每个接口可能还会有一个 ingress qdisc，用来对入向流量执行策略（which polices traffic coming in）。 关于 handle： 每个 handle 由两部分组成，&lt;major&gt;:&lt;minor&gt;。 按照惯例，root qdisc 的 handle 为 1:，这是 1:0 的简写。 每个 qdisc 的 minor number 永远是 0。 关于 class： 每个 class 的 major number 必须与其 parent 一致。 major number 在一个 egress 或 ingress 内必须唯一。 minor number 在一个 qdisc 或 class 内必须唯一。 上面的解释有点模糊，可对照 tc(8) man page 的解释： 所有 qdiscs、classes 和 filters 都有 ID，这些 ID 可以是指定的，也可以是自动分的。 ID 格式 `&lt;major&gt;:&lt;minor&gt;`，`major` 和 `minor` 都是 16 进制数字，不超过 2 字节。 两个特殊值： - `root` 的 `major` 和 `minor` 初始化全 1。 - 省略未指定的部分将为全 0。 下面分别介绍以上三者的 ID 规范。 - qdisc：qdisc 可能会有 children。 - major 部分：称为 handle，表示的 qdisc 的唯一性。 - minor 部分：留给 class 的 namespace。 - class：class 依托在 qdisc 内， - major 部分：继承 class 所在的 qdisc 的 major。 - minor 部分：称为 classid，在所在的 qdisc 内唯一就行。 - filter：由三部分构成，只有在使用 hashed filter hierarchy 时才会用到。 译者注。 2.5.2.1 如何用过滤器（filters ）对流量进行分类 综上，一个典型的 handle 层级如下： 1: root qdisc | 1:1 child class / | \\ / | \\ / | \\ / | \\ 1:10 1:11 1:12 child classes | | | | 11: | leaf class | | 10: 12: qdisc / \\ / \\ 10:1 10:2 12:1 12:2 leaf classes 但不要被这棵树迷惑！不要以为内核位于树的顶点，网络位于下面。包只会通过 root qdisc 入队或出队（get enqueued and dequeued），这也是内核唯一与之交互的部分（ the only thing the kernel talks to）。 一个包可能会被链式地分类如下（get classified in a chain）： 1: -&gt; 1:1 -&gt; 1:12 -&gt; 12: -&gt; 12:2 最后到达 attach 到 class 12:2 的 qdisc 的队列。在这个例子中，树的每个“节点”（ node）上都 attach 了一个 filter，每个 filter 都会给出一个判断结果，根据判断结果 选择一个合适的分支将包发送过去。这是常规的流程。但下面这种流程也是有可能的： 1: -&gt; 12:2 在这种情况下，attach 到 root qdisc 的 filter 决定直接将包发给 12:2。 2.5.2.2 包是如何从 qdisc 出队（dequeue）然后交给硬件的 当内核决定从 qdisc dequeue packet 交给接口（interface）发送时，它会 1. 向 root qdisc `1:` 发送一个 dequeue request 2. `1:` 会将这个请求转发给 `1:1`，后者会进一步向下传递，转发给 `10:`、`11:`、`12:` 3. 每个 qdisc 会查询它们的 siblings，并尝试在上面执行` dequeue() `方法。 在这个例子中，内核需要遍历整棵树，因为只有 12:2 中有数据包。 简单来说，嵌套类（nested classes）只会和它们的 parent qdiscs 通信，而永远不会直 接和接口交互。内核只会调用 root qdisc 的 dequeue() 方法！ 最终结果是，classes dequeue 的速度永远不会超过它们的 parents 允许的速度。而这正 是我们所期望的：这样就能在内层使用一个 SFQ 做纯调度，它不用做任何整形的工作 ；然后在外层使用一个整形 qdisc 专门负责整形。 2.5.3 PRIO qdisc（优先级排队规则） PRIO qdisc 实际上不会整形，只会根据设置的过滤器对流量进行分类。 可以将 PRIO qdisc 理解为 pfifo_fast qdisc 的升级版，它也有多个 band，但 每个 band 都是一个独立的 class，而不是简单的 FIFO。 当一个包 enqueue 到 PRIO qdisc 之后，它会根据设置的 filters 选择一个 class ，并将包送到这个 class。默认情况下会创建三个 class。每个 class 默认情况下都包含一 个纯 FIFO qdisc，没有其他内部结构，但你可以用其他类型的 qdisc 替换掉 FIFO。 当从 PRIO qdisc 取出（dequeue）一个包时，会先尝试 :1。只有 lower bands/classes 没有数据包可取时，才会尝试 higher classes。 如果想基于 tc filters 而不仅仅是 TOS flags 做流量优先级分类时，这个 qdisc 会非常 有用。还可以向这三个预置的 classes 添加额外的 qdisc，毕竟 pfifo_fast 只能提供简 单的 FIFO qdisc。 由于 PRIO** 没有流量整形功能**，因此针对 SFQ 的忠告也适用于这里： 1. 如果你的物理链路已经打满了，可以用 PRIO qdisc （对流量进行分类），或者 2. 在外层嵌套一个 classful qdisc，后者负责流量整形。 用正式的术语来说，PRIO qdisc 是一个** work-conserving 调度器（随到随发）**。 2.5.3.1 参数与用法 下面几个参数能被 tc 识别： bands 需要创建的 band 数量。这个每个 band 实际上都是一个 class。如果改变这个配置， 还需要同时修改 priomap 参数。 priomap 如果没有提供 tc filters 来指导如何对流量分类，那 PRIO qdisc 将依据 TC_PRIO 优先级来决定优先级。这里的工作方式与 pfifo_fast qdisc 是类似的， 更多细节可以参考前面的 pfifo_fast 小节。 PRIO qdisc 里面的 band 都是 class，默认情况下名字分别为 major:1、 major:2、 major:3， 因此如果你的 PRIO qdisc 是 12:，那 tc filter 送到 12:1 的流量就有更高的优先级。 重复一遍：band 0 对应的 minor number 是 1！ band 1 对应的 minor number 是 2 ，以此类推。 2.5.3.2 示例配置 我们将创建一棵如下所示的树： 1: root qdisc / | \\ / | \\ / | \\ 1:1 1:2 1:3 classes | | | 10: 20: 30: qdiscs qdiscs sfq tbf sfq band 0 1 2 高吞吐流量（Bulk traffic）将送到 30:，交互式流量（interactive traffic）将送到 20: 或 10:。 命令行： $ tc qdisc add dev eth0 root handle 1: prio # This *instantly* creates classes 1:1, 1:2, 1:3 $ tc qdisc add dev eth0 parent 1:1 handle 10: sfq $ tc qdisc add dev eth0 parent 1:2 handle 20: tbf rate 20kbit buffer 1600 limit 3000 $ tc qdisc add dev eth0 parent 1:3 handle 30: sfq 然后查看创建出来的 qdisc： # tc -s qdisc ls dev eth0 qdisc sfq 30: quantum 1514b Sent 0 bytes 0 pkts (dropped 0, overlimits 0) qdisc tbf 20: rate 20Kbit burst 1599b lat 667.6ms Sent 0 bytes 0 pkts (dropped 0, overlimits 0) qdisc sfq 10: quantum 1514b Sent 132 bytes 2 pkts (dropped 0, overlimits 0) qdisc prio 1: bands 3 priomap 1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1 Sent 174 bytes 3 pkts (dropped 0, overlimits 0) 可以看到，band 0 已经有了一些流量，而且在执行这条命令的过程中，刚好又发送了一个 包！ 现在我们来用 scp 命令传输一些数据，它会自动设置 TOS flags： $ scp tc ahu@10.0.0.11:./ ahu@10.0.0.11's password: tc 100% |*****************************| 353 KB 00:00 $ tc -s qdisc ls dev eth0 qdisc sfq 30: quantum 1514b Sent 384228 bytes 274 pkts (dropped 0, overlimits 0) qdisc tbf 20: rate 20Kbit burst 1599b lat 667.6ms Sent 2640 bytes 20 pkts (dropped 0, overlimits 0) qdisc sfq 10: quantum 1514b Sent 2230 bytes 31 pkts (dropped 0, overlimits 0) qdisc prio 1: bands 3 priomap 1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1 Sent 389140 bytes 326 pkts (dropped 0, overlimits 0) 可以看到，所有的流量都进入了优先级最低的 handle 30:，这正是我们期望的。为了验证交互式流量会进入优先级更高的 bands，我们可以生成一些交互式流量。 然后再来查看统计： # tc -s qdisc ls dev eth0 qdisc sfq 30: quantum 1514b Sent 384228 bytes 274 pkts (dropped 0, overlimits 0) qdisc tbf 20: rate 20Kbit burst 1599b lat 667.6ms Sent 2640 bytes 20 pkts (dropped 0, overlimits 0) qdisc sfq 10: quantum 1514b Sent 14926 bytes 193 pkts (dropped 0, overlimits 0) qdisc prio 1: bands 3 priomap 1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1 Sent 401836 bytes 488 pkts (dropped 0, overlimits 0) 正如预期 —— 所有额外流量都进入了 10:，这是我们优先级最高的 qdisc。handle 30: 的流量这次没有增长，而刚才它吸收了所有的 scp 流量。 2.5.4 著名的 CBQ（Class Based Queueing）qdisc 前面提到，CBQ（Class Based Queueing，基于类的排队） 是最复杂、最花哨、最少被理 解、也可能是最难用对的 qdisc。这并非因为它的发明者都是魔鬼或者能力不够，而是 因为 CBQ** 算法经常不够精确**，而这是由于它与 Linux 的工作方式不是太匹配造成的。 除了是 classful qdisc 之外，CBQ 还是一个整流器（shaper），作为一个整流器来说， 其实它工作地并不是非常理想。理想的工作方式应该是这样的：如果想将一个 10Mbps 的连 接整形为 1Mbps，那这条链路应该有 90% 的时间是空闲的。否则，我们就需要 throttle 来确保链路 90% 的时间是空闲的。 但空闲时间是很难测量的，CBQ 的方式是：用硬件层连续两次请求数据的时间间隔（ 毫秒）来推算。这可以用来近似估计链路的空闲状态（how full or empty the link is）。 这种测量方式是非常间接的，因此结果并不总是很准确。例如，接口的物理带宽是 100Mbps ，但它可能永远打不到 100Mbps，而原因可能是网卡驱动写的太烂。另一个例子，PCMCIA 网 卡永远打不到 100Mbps，这是由于其总线设计导致的 —— 因此，又回到那个问题：应该如何计算空闲时间？ 当考虑到非纯物理网络设备（not-quite-real network devices）时，例如 PPP over Ethernet 或 PPTP over TCP/IP，情况会更加糟糕。在这些场景中，有效带宽可能是由到用户空间的管道（pipe）效率决定的 —— 这个值可能很高。 真正测量过的人会发现，CBQ 并不是永远很精确，有时甚至完全偏离了真实值。 但在某些场景下，CBQ 能很好地满足需求。基于本文的介绍，你应该能恰当地配置 CBQ，使 其在大部分情况下都工作良好。 2.5.4.1 CBQ shaping 详解 如前所述，CBQ 的工作原理是：在发送包之前等待足够长的时间，以将带宽控制到期望 的阈值。为实现这个目标，它需要计算包之间的等待间隔。 系统在运行过程中会计算一个有效空闲时间（effective idletime）：用指数加权移动平均（ exponential weighted moving average，EWMA）来计算，这个算法假设包的优先级大小 是指数变化的，越近的包（recent packets）优先级越高。UNIX 的 loadaverage 指标 就是用的这个算法。 平均空闲时间（avgidle）的定义：avgidle = 有效空闲时间（EWMA）- 计算出的空闲时间， 1. 理想的未过载链路（loaded link）：avgidle = 0，每经过精确地计算出的时间间隔，就有一个数据 包到来（packets arrive exactly once every calculated interval）。 2. 过载链路（overloaded link）：avgidle &lt; 0，如果这个负值变得太大，CBQ 会关闭一 会，表示超出限制了（overlimit）。 3. 空闲链路（idle link）：avgidle &lt; 0，而且这个值可能会非常大，这可能会导致 累积几个小时之后，算法允许无限大的带宽（infinite bandwidths after a few hours of silence）。 为防止这种情况发生，avgidle 会设置一个上限（maxidle）。 如果发生 overlimit，理论上 CBQ 会严格等待 calculated_idletime，然后才发生下一个 包，然后再次 throttle 自己。但此时也要注意 minburst 参数，见下面。 下面是整形（shaping）相关的配置参数： avpkt 平均包长，单位是字节。计算 maxidle 时会用到。 bandwidth 设备的物理带宽，计算 idle time 时会用到。 cell 包长的增长步长。设备发送不同长度的包时，耗时可能是不一样的，与包长有关。 例如，一个 800Byte 和一个 806Byte 的包所花的发送时间可能是一样的。默认值通常是 8，必须是 2 的幂次。 maxburst 计算 maxidle 时用到，单位：包数（number of packets）。 当 avgidle == maxidle 时，可以并发发送 maxburst 个包，直到 avgidle == 0。 注意 maxidle 是无法直接设置的，只能通过这个参数间接设置。 minburst 前面提到，overlimit 情况下 CBQ 要执行 throttle。理想情况下是精确 throttle calculated idel time，然后发送一个包。但对 Unix 内核来说，通常很难调度 10ms 以下精度的事件，因此最好的方式就是 throttle 更长一段时间，然后一次发 送 minburst 个包，然后再睡眠 minburst 倍的时间。 The time to wait is called the offtime。从较长时间跨度看，更大的 minburst 会使得整形更加精确，但会导致在毫秒级别有更大的波动性。 minidle 如果 avgidle &lt; 0，那说明 overlimits，需要等到 avgidle 足够大才能发送下一个包。 为防止突然的 burst 打爆链路带宽，当 avgidle 降到一个非常小的值之后，会 reset 到 minidle。 minidle 的单位是负微秒（negative microseconds），因此 10 就表示 idle time 下限是 -10us。 mpu 最小包长（Minimum packet size）—— 需要这个参数是因为，即使是零字节的包在以太 网上传输时也会被填充到 64 字节，因此总会有一个发送耗时。 CBQ 需要这个参数来精确计算 idle time。 rate 期望的离开这个 qdisc 的流量速率（rate of traffic）—— 这就是“速度旋钮”（speed knob）！ 在内部，CBQ 有很多优化。例如，在 dequeue 包时，已经明确知道没有数据的 class 都会跳过。 Overlimit 的 class 会通过降低其有效优先级（effective priority）的方式进行惩罚。 所有这些都是很智能也很复杂的。 2.5.4.2 CBQ classful behaviour 除了整形之外，基于前面提到的 idletime 近似，CBQ 也能完成类似 PRIO queue 的功能 ，因为 class 可以有不同优先级，优先级高的总是限于优先级低的被 poll。 每次硬件层请求一个数据包来发送时，都会开启一个 weighted round robin （WRR）过程， 从优先级最高的 class 开始（注意，优先级越高对应的 priority number 越小）。 优先级相同的 class 会作为一组，依次判断它们是否有数据要发送。 下列参数控制 WRR 过程： ","link":"https://RenzoWang.github.io/Notes.github.io/post/tc/"},{"title":"WebRTC 环境配置（Windows 平台）","content":"万事开头难啊，webRTC配置过程中遇到的问题多种多样，有些问题很难搜索到，因此我记录下来供自己参考。 写在前面的话 鉴于WebRTC更新太快，所以网上很多编译方法都失效了，所以如果你看到是几年前的文章，就没必要较真了。本文写作时间为2020年9月16日，WebRTC为当前最新版本。请诸君参考。（另，本人所在地为HK，因此不需要稳定的梯子，希望大家能找到稳定的梯子。） 1.准备 a) Win 10 64bit 1909 b) Visual Studio 2019 Community 16.7.30503.244 c) Windows 10 SDK Windows 10.0.19041.1 d) Python Python 3.8.5 64bit，编译过程中需添加到Path环境变量 f) depot_tools depot_tools是包含下载、编译的相关工具，需要先下载并配置它，才能继续后面的操作。 下载地址:depot_tools 下载后解压，并将解压好的depot_tools目录添加到path系统环境变量中，如下图所示： 2 环境变量配置 有大量的环境变量需要配置，如果在cmd中set需要保持该窗口。一般在系统环境变量编辑里比较简单方便。 最开始我的设置如下： DEPOT_TOOLS_UPDATE=0 #不更新depot_tools DEPOT_TOOLS_WIN_TOOLCHAIN=0 #编译时使用本机VS工具链 GYP_MSVS_VERSION = 2019 #指定VS版本 GYP_MSVS_OVERRIDE_PATH = C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community #vs安装路径，替换成自己的 GYP_GENERATORS=msvs-ninja,ninja #使用ninja编译 Error depot_tools/python3_bin_reldir.txt: No such file or directory failed to determine Python version 我认为是环境变量阻止了其在Windows下的引导，因此删去DEPOT_TOOLS_UPDATE=0 的环境变量即可. 3.获取WebRTC源码 接着执行gclient命令，安装编译需要用到的一些工具，比如git以及python。 其他的环境变量我们已经在前文设置，无需通过cmd进行设置，这是为了我自己的方便，如果对于环境变量有要求，请在cmd自行设置，例： set vs2019_install=C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community set GYP_MSVS_OVERRIDE_PATH=C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community set GYP_GENERATORS=msvs-ninja,ninja # 告诉depot_tools使用我们本机的VS进行编译 set DEPOT_TOOLS_WIN_TOOLCHAIN=0 然后cd到要放源码的地方（要遵守前面说的磁盘要求），执行： mkdir webrtc-checkout cd webrtc-checkout fetch --nohooks webrtc gclient sync 这一过程的时间比较长，包括源码以及一些测试的音视频文件资源等。如果没有稳定快速的梯子需要等待较长时间。 如果因为网络等原因中断了，就再执行gclient sync。如果这一步一直卡着不动，可以执行ctrl+c，然后执行gclient sync。 4.编译 生成VS2019工程文件： cd src gn gen --ide=vs out/Default 可以在src\\out\\Default\\ 下得到 all.sln解决方案文件。 如果不想使用默认编译参数，可以使用gn args out/Default --list查看当前编译参数，通过类似如下方式设置： gn gen --ide=vs out/Default --args=“use_rtti=true is_clang=false rtc_build_tools=false rtc_include_tests=false rtc_build_examples=false” 接着执行编译命令： ninja -C out/Default 代码更新 git checkout master git pull origin master gclient sync 引用WebRTC库 WebRTC编译后会在src\\out\\Default\\obj目录下生成整个WebRTC工程的静态库：webrtc.lib，链接下这个就可以了。 ","link":"https://RenzoWang.github.io/Notes.github.io/post/webrtc-huan-jing-pei-zhi/"},{"title":"C++学习笔记","content":" Chapter 8 指针、引用 指针—— 存储内存地址 变量 ——占用空间、声明、初始化（否则值为随机） 8.1 运算符 1.1 使用引用运算符（&amp;）获取变量地址 e.g. Varname —— 变量 &amp;Varname —— 存储该变量内存地址 1.2 使用接触引用运算符（*） 以此访问包含地址的值 e.g. 有合法指针——pData 那么该指针地址处存储的值可用 *pData 来获取 1.3 sizeof() 用于指针时，结果取决于编译器及针对的操作系统，与指针变量无关。 8.2 动态内存分配 1. 关键字new &amp; delete 动态分配和释放内存 new分配新的内存块，若成功，返回一个指针，指向新分配的内存，否则引发异常（使用时，指定数据类型分配内存） Type* Pointer = new Type; Type* Pointer = new Type[ Num Elements ]; e.g. int * pNumber = new int; int * pNumber = new int[ 10 ]; 注 ：请求分配内存并不保证请求能够得到满足，取决于系统状态机内存资源的可用性。 使用关键字 new 分配的内存最终使用对应的关键字 delete 释放 Type* Pointer = new Type; delete Pointer; 或 Type* Pointer = new Type[ Num Elements ]; delete [] Pointer; 2. 递增（++）、递减（--）运算符作用于指针的结果 对指针执行递增 / 递减， 指向的是内存中相邻的值，而不是相邻的字节（除非值的长度刚好1字节，例如char） Type * pType = Address; ++pType --&gt; Adress + sizeof( Type ) 3. 关键字const作用于指针 const指针有三种： a ）指针直线的数据为常量，不可修改，但可以修改包含的地址（指针可指向其他地址） b ) 指针包含地址为常量，不能修改，可以修改数据 c ) 最为严格的情况，地址及值均为常量，均不可修改，但更易于维护。 4. 将指针传递给函数 将内存空间传递给函数，其中可包含值，可包含结果 注意传入的数据是否需要修改或者经过计算。 5. 数组与指针 可以将数组变量赋值给类型相同的指针。 8.3 常见错误 1.内存泄露 常见原因是未正确释放内存 2.指向无效的内存单元 无效指针 3.悬浮指针 亦可称之为迷途/失控指针 为便面此类问题，初始化/释放指针后将其置为NULL，并在解除引用前（使用关键字 ** * **）检查其是否有效。 8.4 编程实践 Step1 初始化指针变量 step2 使用前判断指针是否为NULL——&gt;异常处理，在new（创建指针）失败时妥善退出 Step3 仅在其有效时使用 Step4 new之后必用关键字delete释放内存，且delete后不再访问该指针 8.5 引用（&amp;） 引用是变量的别名（相应变量的的另一个名字，指向相同的内存单元） VarType Original = Value; VarType &amp; ReferenceVariable = Original; 1.引用的用处 避免了传参时因参数占用内存过大，复制时也会开销很大。 2. const 用于引用 禁止通过引用修改其指向的变量的值。 const引用参数不能作用于左值 3. 按引用向函数传递参数 可避免将形参复制给形参，从而极大提高性能。然而，让被调用的函数直接使用调用函数栈时，确保被调用函数不能修改调用函数中的变量很重要。因此，可将引用声明为const Chapter 9 类和对象 9.1 类和对象简述 1. 类的声明 关键字 class 依次包含类名、成员属性、方法（属于类成员的函数）及结尾分号（;） 即通过关键字class创建数据类型，并封装属性。 &quot;封装&quot; 将数据及使用它们的方法进行逻辑编组 2.实例化对象 在使用时，根据类实例化一个对象，通过对象访问成员方法及属性。 class Human { string Name; string DateofBirth; void Talk( string TexttoTalk ); }; 那么实例化一个对象Tom //方法一 Human Tom; //方法二 Human* pAnotherHuman = new Human( ); delete pAnotherHuman; 3.通过句点运算符（.）访问成员 句点运算符（.）用于访问对象的属性。这同样适用于方法。 Human Tom; Tom. DateofBirth = &quot;1970&quot; ; Huamn* pTom = new Human(); (*pTom).IntroduceSelf();//使用间接运算符（*）获取对象，再使用句点运算符来访问成员。 4. 使用指针运算符访问成员（-&gt;） 若对象使用new实例化或有指向对象的指针，则可以使用 **指针运算符（-&gt;）**来访问成员属性和方法。 Chapter 11 ** 11.1. 多态基础 1.1 类之间存在层次结构，类是通过继承相关联时，通过多态来表示。 多态意味着调用成员函数时，根据函数的对象类型执行不同的方法。（而不是调用预设的基类中的函数方法），即表现实际类型。 1.2 使用虚函数实现多态行为 将基类中方法声明为虚函数，使用关键字 virtual， 确保编译器调用覆盖版本（子类、派生类）。 多态行为 将派生类对象视为几类对象，并执行派生类的函数（方法）实现。 1.3 为何需要虚构造函数 除了需要使用派生类对象，还需要避免计算机资源未释放、内存泄露等问题（即将实例化的派生类对象，将其值赋给基类当做指针，并通过该指针调用 delete， 将不会调用派生类的析构函数） **⬇** 那么将析构函数声明为虚函数，确保通过基类指针调用delete时，不会调用派生类析构函数 class Base { public: virtual ~Base() }; auto 关键字 利用auto关键字，通过编译器检查变量的初始值，并将该变量类型设置为该返回值的类型。能够简化编码工作。 std::vector&lt;int&gt; MyNumbers; //常规 for (vector&lt;int&gt;::const_iterator Iterator = MyNumbers.begin(); Iterator &lt; MyNumbers.end(); ++Iterator ) std::cout &lt;&lt; * Iterator&lt;&lt; &quot; &quot;; //利用auto关键字 for (auto Iterator = MyNumbers.begin(); Iterator &lt; MyNumbers.end(); ++Iterator ) std::cout &lt;&lt; * Iterator&lt;&lt; &quot; &quot;; ** ","link":"https://RenzoWang.github.io/Notes.github.io/post/learnC/"},{"title":"关于","content":" 欢迎来到我的小站呀，很高兴遇见你！🤝 #KTBFFH 💙 CHELSEA 🏠 关于本站 重新开始学习计算机语言， 👨‍💻 博主是谁 ⛹ 兴趣爱好 CHELSEA、DOTA 📬 联系我呀 githubwrz@163.com ","link":"https://RenzoWang.github.io/Notes.github.io/post/about/"}]}