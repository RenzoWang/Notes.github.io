<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://RenzoWang.github.io/Notes.github.io</id>
    <title>Renzo&apos;s Blog</title>
    <updated>2023-02-20T11:06:29.990Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://RenzoWang.github.io/Notes.github.io"/>
    <link rel="self" href="https://RenzoWang.github.io/Notes.github.io/atom.xml"/>
    <logo>https://RenzoWang.github.io/Notes.github.io/images/avatar.png</logo>
    <icon>https://RenzoWang.github.io/Notes.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, Renzo&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[队列Queue及实现]]></title>
        <id>https://RenzoWang.github.io/Notes.github.io/post/dui-lie-queue-ji-shi-xian/</id>
        <link href="https://RenzoWang.github.io/Notes.github.io/post/dui-lie-queue-ji-shi-xian/">
        </link>
        <updated>2023-02-12T15:30:51.000Z</updated>
        <content type="html"><![CDATA[<p>article_content<div id="article_content" class="article_content clearfix"><br>
<link rel="stylesheet" href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/kdoc_html_views-1a98987dfd.css"><br>
<link rel="stylesheet" href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-6e43165c0a.css"><br>
<div id="content_views" class="htmledit_views"><br>
<div id="csdn-toolbar" style="margin-left:0;"></p>
 <div style="margin-left:0;"> 
  <div style="margin-left:auto;"> 
   <div style="margin-left:0;"> 
    <blockquote> 
     <h1 style="margin-left:0px;"><a name="t0"></a>一：队列Queue</h1> 
    </blockquote> 
   </div> 
  </div> 
 </div> 
</div> 
<div style="margin-left:0;"> 
 <div id="mainBox" style="margin-left:8px;"> 
  <div style="margin-left:0;"> 
   <div id="article_content" style="margin-left:0;"> 
    <div id="content_views" style="margin-left:0;"> 
     <p style="margin-left:0;"><span style="color:#333333;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">队列是一种特殊的<a class="hl hl-1" href="https://so.csdn.net/so/search?q=%E7%BA%BF%E6%80%A7&amp;spm=1001.2101.3001.7020" title="线性">线性</a>表，</span></span></span><span style="color:#fe2c24;"><span style="background-color:#ffffff;"><strong>遵循先入先出、后入后出的基本原则</strong></span></span><span style="color:#333333;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">，一般来说，它只允许在表的前端进行删除操作，而在表的后端进行插入操作，但是java的某些队列运行在任何地方插入删除；比如我们常用的 LinkedList 集合，它实现了Queue 接口，因此，我们可以理解为&nbsp;LinkedList 就是一个队列；</span></span></span></p> 
     <h1 style="margin-left:0;"><a name="t1"></a><span style="color:#333333;"><span style="background-color:#ffffff;"><strong><span style="color:#4f4f4f;"><a name="t1"></a><img alt="" height="211" src="https://img-blog.csdnimg.cn/20210424160130335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTg0NDk3,size_16,color_FFFFFF,t_70" width="1005"></span></strong></span></span></h1> 
     <h2 style="margin-left:0px;"><a name="t2"></a><span style="color:#333333;"><span style="background-color:#ffffff;"><strong><span style="color:#4f4f4f;">1：队列特性</span></strong></span></span></h2> 
     <p style="margin-left:0;"><span style="color:#333333;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">队列主要分为阻塞和非阻塞，有界和无界、<a class="hl hl-1" href="https://so.csdn.net/so/search?q=%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8&amp;spm=1001.2101.3001.7020" title="单向链表">单向链表</a>和双向链表之分；</span></span></span></p> 
     <h3 style="margin-left:0;"><a name="t3"></a><span style="color:#333333;"><span style="background-color:#ffffff;"><strong><span style="color:#4f4f4f;"><a name="t3"></a>阻塞和非阻塞</span></strong></span></span></h3> 
     <p style="margin-left:0;"><span style="color:#333333;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><strong>阻塞队列</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;入列(添加元素)时，如果元<a class="hl hl-1" href="https://so.csdn.net/so/search?q=%E7%B4%A0%E6%95%B0&amp;spm=1001.2101.3001.7020" title="素数">素数</a>量超过队列总数，会进行等待（阻塞），待队列的中的元素出列后，元素数量未超过队列总数时，就会解除阻塞状态，进而可以继续入列；<br> &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;出列(删除元素)时，如果队列为空的情况下，也会进行等待（阻塞），待队列有值的时候即会解除阻塞状态，进而继续出列；<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 阻塞队列的好处是可以防止队列容器溢出；只要满了就会进行阻塞等待；也就不存在溢出的情况；<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 只要是阻塞队列，都是线程安全的；<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span></span></span></p> 
     <p style="margin-left:0;"><span style="color:#333333;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><strong>非阻塞队列</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 不管出列还是入列，都不会进行阻塞，<br> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;入列时，如果元素数量超过队列总数，则会抛出异常，<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 出列时，如果队列为空，则取出空值；</span></span></span></p> 
     <p style="margin-left:0;"><span style="color:#333333;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">一般情况下，非阻塞式队列使用的比较少，一般都用阻塞式的对象比较多；阻塞和非阻塞队列在使用上的最大区别就是阻塞队列提供了以下2个方法：</span></span></span></p> 
     <ul style="margin-left:0;"><li><span style="color:#333333;"><span style="background-color:#ffffff;">&nbsp; &nbsp; 出队阻塞方法 ：<span style="color:#f33b45;"><strong>&nbsp;take()</strong></span></span></span></li><li><span style="color:#333333;"><span style="background-color:#ffffff;">&nbsp; &nbsp; 入队阻塞方法 ：<strong><strong><span style="color:#f33b45;">&nbsp;put()</span></strong></strong></span></span></li></ul>
     <p style="margin-left:0;"><span style="color:#333333;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">&nbsp;</span></span></span></p> 
     <h3 style="margin-left:0;"><a name="t4"></a><span style="color:#333333;"><span style="background-color:#ffffff;"><strong><span style="color:#4f4f4f;"><a name="t4"></a>有界和无界</span></strong></span></span></h3> 
     <p style="margin-left:0;"><span style="color:#333333;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">&nbsp;&nbsp; &nbsp;<strong>有界</strong>：有界限，大小长度受限制<br> &nbsp;<strong>&nbsp; &nbsp;无界</strong>：无限大小，其实说是无限大小，其实是有界限的，只不过超过界限时就会进行扩容，就行ArrayList 一样，在内部动态扩容<br> &nbsp; &nbsp;</span></span></span></p> 
     <h3 style="margin-left:0;"><a name="t5"></a><span style="color:#333333;"><span style="background-color:#ffffff;"><strong><span style="color:#4f4f4f;"><a name="t5"></a>单向链表和<a class="hl hl-1" href="https://so.csdn.net/so/search?q=%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8&amp;spm=1001.2101.3001.7020" title="双向链表">双向链表</a></span></strong></span></span></h3> 
     <p style="margin-left:0;"><span style="color:#333333;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><strong>单向链表 ：&nbsp;</strong>每个元素中除了元素本身之外，还存储一个指针，这个指针指向下一个元素；</span></span></span></p> 
     <p style="margin-left:0;"><span style="color:#333333;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><img alt="" height="360" src="https://img-blog.csdnimg.cn/20210424161031283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTg0NDk3,size_16,color_FFFFFF,t_70" width="941"></span></span></span></p> 
     <p style="margin-left:0;"><span style="color:#333333;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><strong>双向链表 ：</strong>除了元素本身之外，还有两个指针，一个指针指向前一个元素的地址，另一个指针指向后一个元素的地址；</span></span></span></p> 
     <p style="margin-left:0;"><span style="color:#333333;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><img alt="" height="362" src="https://img-blog.csdnimg.cn/20210424161404577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTg0NDk3,size_16,color_FFFFFF,t_70" width="951"></span></span></span></p> 
     <h2 style="margin-left:0px;"><a name="t6"></a><span style="color:#333333;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">2：</span></span></span><strong><span style="color:#4f4f4f;">Java 队列接口继承图</span></strong></h2> 
     <p style="margin-left:0;"><span style="color:#333333;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><img alt="" height="549" src="https://img-blog.csdnimg.cn/20210424172014888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MTg0NDk3,size_16,color_FFFFFF,t_70" width="726"></span></span></span></p> 
     <p style="margin-left:0;"><span style="color:#333333;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">&nbsp;</span></span></span></p> 
     <h2 style="margin-left:0px;"><a name="t7"></a><span style="color:#333333;"><span style="background-color:#ffffff;"><strong><span style="color:#4f4f4f;"><a name="t7"></a>3：队列常用方法</span></strong></span></span></h2> 
     <p style="margin-left:0;"><span style="color:#333333;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><strong>　　add</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;增加一个元索&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果队列已满，则抛出一个IIIegaISlabEepeplian异常<br><strong>　　remove</strong>&nbsp;&nbsp;&nbsp;移除并返回队列头部的元素&nbsp;&nbsp;&nbsp;&nbsp;如果队列为空，则抛出一个NoSuchElementException异常<br><strong>　　element&nbsp;&nbsp;</strong>返回队列头部的元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果队列为空，则抛出一个NoSuchElementException异常<br><strong>　　offer</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;添加一个元素并返回true&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果队列已满，则返回false<br><strong>　　poll</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;移除并返问队列头部的元素&nbsp;&nbsp;&nbsp;&nbsp;如果队列为空，则返回null<br><strong>　　peek</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回队列头部的元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果队列为空，则返回null<br><strong>　　put</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;添加一个元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果队列满，则阻塞<br><strong>　　take</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;移除并返回队列头部的元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果队列为空，则阻塞<br> &nbsp; &nbsp; &nbsp; &nbsp;<strong>drainTo(list)&nbsp; &nbsp;</strong>一次性取出队列所有元素</span></span></span></p> 
     <p style="margin-left:0;"><span style="color:#333333;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><strong>知识点： remove、element、offer&nbsp;、poll、peek&nbsp;其实是属于Queue接口。&nbsp;</strong></span></span></span></p> 
     <h2 style="margin-left:0px;"><a name="t8"></a></h2> 
     <h2 style="margin-left:0px;"><a name="t9"></a><strong><span style="color:#4f4f4f;">4：阻塞队列与</span></strong><span style="color:#333333;"><span style="background-color:#ffffff;"><strong><span style="color:#4f4f4f;">非阻塞队列具体</span></strong><span style="color:#4d4d4d;">详解</span></span></span></h2> 
     <h3 style="margin-left:0px;"><a name="t10"></a><span style="color:#333333;"><span style="background-color:#ffffff;"><strong><span style="color:#4f4f4f;">非阻塞队列：</span></strong></span></span></h3> 
     <h3 style="margin-left:0;"><a name="t11"></a><span style="color:#333333;"><span style="background-color:#ffffff;"><strong><span style="color:#4f4f4f;"><a name="t9"></a>1、ConcurrentLinkedQueue</span></strong></span></span></h3> 
     <p style="margin-left:0;"><span style="color:#333333;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">&nbsp; 单向链表结构的无界并发队列, 非阻塞队列，由CAS实现线程安全，内部基于节点实现</span></span></span></p> 
     <h3 style="margin-left:0;"><a name="t12"></a><span style="color:#333333;"><span style="background-color:#ffffff;"><strong><span style="color:#4f4f4f;"><a name="t10"></a>2、ConcurrentLinkedDeque &nbsp;</span></strong></span></span></h3> 
     <p style="margin-left:0;"><span style="color:#333333;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">双向链表结构的无界并发队列, 非阻塞队列，由CAS实现线程安全&nbsp; &nbsp;&nbsp;</span></span></span></p> 
     <h3 style="margin-left:0;"><a name="t13"></a><span style="color:#333333;"><span style="background-color:#ffffff;"><strong><span style="color:#4f4f4f;"><a name="t11"></a>3、PriorityQueue</span></strong></span></span></h3> 
     <p style="margin-left:0;"><span style="color:#333333;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">内部基于数组实现，线程不安全的队列</span></span></span></p> 
     <p style="margin-left:0;"><strong><span style="color:#4f4f4f;">阻塞队列：</span></strong></p> 
     <h3 style="margin-left:0;"><a name="t14"></a><span style="color:#333333;"><span style="background-color:#ffffff;"><strong><span style="color:#4f4f4f;"><a name="t14"></a>1、DelayQueue</span></strong></span></span></h3> 
     <p style="margin-left:0;"><span style="color:#333333;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">一个支持延时获取元素的无界阻塞队列</span></span></span></p> 
     <h3 style="margin-left:0;"><a name="t15"></a><span style="color:#333333;"><span style="background-color:#ffffff;"><strong><span style="color:#4f4f4f;"><a name="t15"></a>2、LinkedTransferQueue</span></strong></span></span></h3> 
     <p style="margin-left:0;"><span style="color:#333333;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">一个由链表结构组成的无界阻塞队列。</span></span></span></p> 
     <p style="margin-left:0;"><a href="https://www.cnblogs.com/kexianting/p/8550844.html" title="Java并发包--LinkedBlockingDeque - ken007 - 博客园">Java并发包--LinkedBlockingDeque - ken007 - 博客园</a></p> 
     <h3 style="margin-left:0;"><a name="t16"></a><span style="color:#333333;"><span style="background-color:#ffffff;"><strong><span style="color:#4f4f4f;"><a name="t16"></a>3、ArrayBlockingQueue</span></strong></span></span></h3> 
     <p style="margin-left:0;"><span style="color:#333333;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">有界队列，阻塞式,初始化时必须指定队列大小，且不可改变；，底层由数组实现；</span></span></span></p> 
     <h3 style="margin-left:0;"><a name="t17"></a><span style="color:#333333;"><span style="background-color:#ffffff;"><strong><span style="color:#4f4f4f;"><a name="t17"></a>4、SynchronousQueue</span></strong></span></span></h3> 
     <p style="margin-left:0;"><span style="color:#333333;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">最多只能存储一个元素，每一个put操作必须等待一个take操作，否则不能继续添加元素</span></span></span></p> 
     <h3 style="margin-left:0;"><a name="t18"></a><span style="color:#333333;"><span style="background-color:#ffffff;"><strong><span style="color:#4f4f4f;"><a name="t18"></a>5、PriorityBlockingQueue</span></strong></span></span></h3> 
     <p style="margin-left:0;"><span style="color:#333333;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">一个带优先级的队列，而不是先进先出队列。元素按优先级顺序被移除，而且它也是无界的，也就是没有容量上限，虽然此队列逻辑上是无界的，但是由于资源被耗尽，所以试图执行添加操作可能会导致 OutOfMemoryError 错误；</span></span></span></p> 
     <p style="margin-left:0;"><strong>博客：</strong></p> 
     <p style="margin-left:0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LinkedBlockingDeque：一个由链表结构组成的双向<a href="https://so.csdn.net/so/search?q=%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97&amp;spm=1001.2101.3001.7020" target="_blank" class="hl hl-1" data-report-view="{&quot;spm&quot;:&quot;1001.2101.3001.7020&quot;,&quot;dest&quot;:&quot;https://so.csdn.net/so/search?q=%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97&amp;spm=1001.2101.3001.7020&quot;,&quot;extra&quot;:&quot;{\&quot;searchword\&quot;:\&quot;阻塞队列\&quot;}&quot;}" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.7020&quot;,&quot;dest&quot;:&quot;https://so.csdn.net/so/search?q=%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97&amp;spm=1001.2101.3001.7020&quot;,&quot;extra&quot;:&quot;{\&quot;searchword\&quot;:\&quot;阻塞队列\&quot;}&quot;}" data-tit="阻塞队列" data-pretit="阻塞队列">阻塞队列</a>。（LinkedBlockingDeque还是可选容量的(防止过度膨胀)，即可以指定队列的容量。如果不指定，默认容量大小等于Integer.MAX_VALUE（@Native public static final int MAX_VALUE = 0x7fffffff））</p> 
     <p>　　ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。&nbsp;</p> 
     <p>　　LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。&nbsp;</p> 
     <p>　　PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。&nbsp;</p> 
     <p>　　LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。&nbsp;</p> 
     <p>　　SynchronousQueue：一个不存储元素的阻塞队列。&nbsp;</p> 
     <p>　　DealyQueue：一个使用优先级队列实现的无界阻塞队列。&nbsp;</p> 
     <p style="margin-left:0;"><a href="https://www.cnblogs.com/aihuxi/p/9704055.html" title="高并发第十三弹:J.U.C 队列  SynchronousQueue.ArrayBlockingQueue.LinkedBlockingQueue.LinkedTransferQueue - 爱呼吸的鱼 - 博客园">高并发第十三弹:J.U.C 队列 SynchronousQueue.ArrayBlockingQueue.LinkedBlockingQueue.LinkedTransferQueue - 爱呼吸的鱼 - 博客园</a></p> 
     <p style="margin-left:0;"></p> 
     <h1 style="margin-left:0px;"><a name="t19"></a>二：<strong>双端队列<span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">Deque</span></span></span></strong></h1> 
     <p><span style="color:#fe2c24;"><strong>双端队列既可以当作队列也可以当作栈！方法中可以先入先出也可以先入后出，因为是双端的，所以栈我们不推荐使用Vector的实现类Stack，推荐使用双端队列<span style="background-color:#ffffff;">ArrayDeque来做栈。</span></strong></span></p> 
     <h3 style="margin-left:0px;"><a name="t20"></a><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">Deque———ArrayDeque类详解</span></span></span></h3> 
     <div style="margin-left:0;"> 
      <div style="margin-left:8px;"> 
       <div style="margin-left:0;"> 
        <div style="margin-left:0;"> 
         <div style="margin-left:0;"> 
          <ul style="margin-left:0;"><li> 
            <div style="margin-left:0;"> 
             <div class="table-box"><table align="center" border="1" cellspacing="0"><tbody><tr><th style="background-color:#eff3f5;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;">类型</span></span></th><th style="background-color:#eff3f5;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;">方法</span></span></th><th style="background-color:#eff3f5;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;">作用</span></span></th></tr><tr><th rowspan="4" style="background-color:#eff3f5;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;">添加元素</span></span></th><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a href="https://blog.csdn.net/lucklycoder/article/details/115381856#one" title="public void addFirst(E e)">public void addFirst(E e)</a></span></span></span></td><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">在数组前面添加元素</span></span></span></td></tr><tr><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a href="https://blog.csdn.net/lucklycoder/article/details/115381856#two" title="public void addLast(E e)">public void addLast(E e)</a></span></span></span></td><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">在数组后面添加元素</span></span></span></td></tr><tr><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a href="https://blog.csdn.net/lucklycoder/article/details/115381856#three" title="public boolean offerFirst(E e)">public boolean offerFirst(E e)</a></span></span></span></td><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">在数组前面添加元素，并返回是否添加成功</span></span></span></td></tr><tr><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a href="https://blog.csdn.net/lucklycoder/article/details/115381856#four" title="public boolean offerLast">public boolean offerLast</a></span></span></span></td><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">在数组后面添加元素，并返回是否添加成功</span></span></span></td></tr><tr><th rowspan="6" style="background-color:#eff3f5;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;">删除元素</span></span></th><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a href="https://blog.csdn.net/lucklycoder/article/details/115381856#five" title="public E pollFirst()">public E pollFirst()</a></span></span></span></td><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">删除第一个元素，并返回删除元素的值，如果元素为null，将返回null</span></span></span></td></tr><tr><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a href="https://blog.csdn.net/lucklycoder/article/details/115381856#six" title="public E removeFirst()">public E removeFirst()</a></span></span></span></td><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">删除第一个元素，并返回删除元素的值,如果元素为null，将抛出异常</span></span></span></td></tr><tr><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a href="https://blog.csdn.net/lucklycoder/article/details/115381856#seven" title="public E pollLast()">public E pollLast()</a></span></span></span></td><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">删除最后一个元素，并返回删除元素的值，如果为null，将返回null</span></span></span></td></tr><tr><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a href="https://blog.csdn.net/lucklycoder/article/details/115381856#eight" title="public E removeLast()">public E removeLast()</a></span></span></span></td><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">删除最后一个元素，并返回删除元素的值，如果为null，将抛出异常</span></span></span></td></tr><tr><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a href="https://blog.csdn.net/lucklycoder/article/details/115381856#nine" title="public boolean removeFirstOccurrence(Object o)">public boolean removeFirstOccurrence(Object o)</a></span></span></span></td><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">删除第一次出现的指定元素</span></span></span></td></tr><tr><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a href="https://blog.csdn.net/lucklycoder/article/details/115381856#ten" title="public boolean removeLastOccurrence(Object o)">public boolean removeLastOccurrence(Object o)</a></span></span></span></td><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">删除最后一次出现的指定元素</span></span></span></td></tr><tr><th rowspan="2" style="background-color:#eff3f5;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;">获取元素</span></span></th><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a href="https://blog.csdn.net/lucklycoder/article/details/115381856#eleven" title="public E getFirst()">public E getFirst()</a></span></span></span></td><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">获取第一个元素,如果没有将抛出异常</span></span></span></td></tr><tr><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a href="https://blog.csdn.net/lucklycoder/article/details/115381856#twelve" title="public E getLast()">public E getLast()</a></span></span></span></td><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">获取最后一个元素，如果没有将抛出异常</span></span></span></td></tr><tr><th rowspan="6" style="background-color:#eff3f5;vertical-align:middle;"><span style="color:#fe2c24;"><span style="background-color:#ffffff;">队列操作</span></span></th><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a href="https://blog.csdn.net/lucklycoder/article/details/115381856#thirteen" title="public boolean add(E e)">public boolean add(E e)</a></span></span></span></td><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">在队列尾部添加一个元素</span></span></span></td></tr><tr><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a href="https://blog.csdn.net/lucklycoder/article/details/115381856#forteen" title="public boolean offer(E e)">public boolean offer(E e)</a></span></span></span></td><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">在队列尾部添加一个元素，并返回是否成功</span></span></span></td></tr><tr><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a href="https://blog.csdn.net/lucklycoder/article/details/115381856#fifteen" title="public E remove()">public E remove()</a></span></span></span></td><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">删除队列中第一个元素，并返回该元素的值，如果元素为null，将抛出异常(其实底层调用的是removeFirst())</span></span></span></td></tr><tr><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a href="https://blog.csdn.net/lucklycoder/article/details/115381856#sixteen" title="public E poll()">public E poll()</a></span></span></span></td><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">删除队列中第一个元素，并返回该元素的值,如果元素为null，将返回null(其实调用的是pollFirst())</span></span></span></td></tr><tr><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a href="https://blog.csdn.net/lucklycoder/article/details/115381856#seventeen" title="public E element()">public E element()</a></span></span></span></td><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">获取第一个元素，如果没有将抛出异常</span></span></span></td></tr><tr><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a href="https://blog.csdn.net/lucklycoder/article/details/115381856#eighteen" title="public E peek()">public E peek()</a></span></span></span></td><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">获取第一个元素，如果返回null</span></span></span></td></tr><tr><th rowspan="2" style="background-color:#eff3f5;vertical-align:middle;"><span style="color:#fe2c24;"><span style="background-color:#ffffff;">栈操作</span></span></th><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a href="https://blog.csdn.net/lucklycoder/article/details/115381856#ninteen" title="public void push(E e)">public void push(E e)</a></span></span></span></td><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">栈顶添加一个元素</span></span></span></td></tr><tr><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a href="https://blog.csdn.net/lucklycoder/article/details/115381856#twenty" title="public E pop()">public E pop()</a></span></span></span></td><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">移除栈顶元素,如果栈顶没有元素将抛出异常</span></span></span></td></tr><tr><th rowspan="9" style="background-color:#eff3f5;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;">其他</span></span></th><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a href="https://blog.csdn.net/lucklycoder/article/details/115381856#twentyone" title="public int size()">public int size()</a></span></span></span></td><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">获取队列中元素个数</span></span></span></td></tr><tr><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a href="https://blog.csdn.net/lucklycoder/article/details/115381856#twentytwo" title="public boolean isEmpty()">public boolean isEmpty()</a></span></span></span></td><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">判断队列是否为空</span></span></span></td></tr><tr><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a href="https://blog.csdn.net/lucklycoder/article/details/115381856#twentythree" title="public Iterator iterator()">public Iterator iterator()</a></span></span></span></td><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">迭代器，从前向后迭代</span></span></span></td></tr><tr><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a href="https://blog.csdn.net/lucklycoder/article/details/115381856#twentyfour" title="public Iterator descendingIterator()">public Iterator descendingIterator()</a></span></span></span></td><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">迭代器，从后向前迭代</span></span></span></td></tr><tr><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a href="https://blog.csdn.net/lucklycoder/article/details/115381856#twentyfive" title="public boolean contains(Object o)">public boolean contains(Object o)</a></span></span></span></td><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">判断队列中是否存在该元素</span></span></span></td></tr><tr><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a href="https://blog.csdn.net/lucklycoder/article/details/115381856#twentysix" title="public Object[] toArray()">public Object[] toArray()</a></span></span></span></td><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">转成数组</span></span></span></td></tr><tr><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a href="https://blog.csdn.net/lucklycoder/article/details/115381856#twentyseven" title="public T[] toArray(T[] a)">public T[] toArray(T[] a)</a></span></span></span></td><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">转成a数组常</span></span></span></td></tr><tr><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a href="https://blog.csdn.net/lucklycoder/article/details/115381856#twentyeight" title="public void clear()">public void clear()</a></span></span></span></td><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">清空队列</span></span></span></td></tr><tr><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a href="https://blog.csdn.net/lucklycoder/article/details/115381856#twentynine" title="public ArrayDeque clone()">public ArrayDeque clone()</a></span></span></span></td><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">克隆(复制)一个新的队列</span></span></span></td></tr></tbody></table></div>
            </div> </li><li><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><a href="https://blog.csdn.net/lucklycoder/article/details/115381856#Nine" title="六.参考资料">六.参考资料</a></span></span></li></ul>
          <hr>
          <h2 id="Zero" style="margin-left:0;"><a name="t21"></a><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">1.数据结构</span></span></span></h2> 
          <span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;">ArrayDeque类是&nbsp;双端队列的线性实现类。</span></span> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">具有以下特征：</span></span></span></p> 
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">☞&nbsp;<a class="hl hl-1" href="https://so.csdn.net/so/search?q=ArrayDeque&amp;spm=1001.2101.3001.7020" title="ArrayDeque">ArrayDeque</a>是采用数组方式实现的双端队列。<br> ☞ ArrayDeque的出队入队是通过头尾指针循环，利用数组实现的。<br> ☞ ArrayDeque容量不足时是会扩容的，每次扩容容量增加一倍。<br> ☞ ArrayDeque可以直接作为栈使用。当用作栈时，性能优于Stack，当用于队列时，性能优于LinkedList。<br> ☞ 无容量大小限制，容量按需增长。<br> ☞ 非线程安全队列，无同步策略，不支持多线程安全访问。<br> ☞ 具有fail-fast特性，不能存储null值，支持双向迭代器遍历。</span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">ArrayDeque的实现结构图如下所示:</span></span></span></p> 
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><img alt="" src="https://img-blog.csdnimg.cn/img_convert/19570e6609b880d77f0353cda85ee0b8.png"></span></span></span></p> 
          <hr>
          <h2 id="One" style="margin-left:0;"><a name="t22"></a><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">2.类标题</span></span></span></h2> 
          <span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;">ArrayDeque类的标题如下：</span></span> 
          <blockquote> 
           <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#555666;">public class ArrayDeque extends AbstractCollection implements&nbsp;<a class="hl hl-1" href="https://so.csdn.net/so/search?q=Deque&amp;spm=1001.2101.3001.7020" title="Deque">Deque</a>, Cloneable, Serializable</span></span></span></p> 
          </blockquote> 
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">这个标题说明ArrayDeque类是AbstractCollection类的子类，并且实现了三个接口：Deque、Cloneable和Serializable。</span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">如下图所示：</span></span></span></p> 
          <p style="margin-left:0;"></p> 
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><img alt="" src="https://img-blog.csdnimg.cn/img_convert/7478f6551e7d804c9e5104e98c8d5e14.png"></span></span></span></p> 
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">1.ArrayDeque实现了Deque接口，即能将LinkedList当做双端队列使用。<br> 2.ArrayDeque实现了Cloneable接口，即覆盖了函数clone()，能克隆。<br> 3.ArrayDeque实现java.io.Serializable接口，LinkedList支持序列化，能通过序列化去传输。<br> 4.ArrayDeque是非同步的[2]。</span></span></span></p> 
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><span style="color:#800080;">【注2】在这里的非同步指的是,当使用线程的时候,对于这个集合对象进行操作,那么不同的线程所获取的这个集合对象是不同的.所以是说不同步,在多线程的形式是不安全的.</span></span></span></span></p> 
          <hr>
          <h2 id="Two" style="margin-left:0;"><a name="t23"></a><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">3.字段</span></span></span></h2> 
          <blockquote> 
           <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#555666;">transient Object[] elements;<br> 存储元素的数组</span></span></span></p> 
          </blockquote> 
          <blockquote> 
           <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#555666;">transient int head;<br> 队列头位置</span></span></span></p> 
          </blockquote> 
          <blockquote> 
           <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#555666;">transient int tail;<br> 队列尾位置</span></span></span></p> 
          </blockquote> 
          <blockquote> 
           <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#555666;">private static final int MIN_INITIAL_CAPACITY = 8;<br> 一个新创建的队列的最小容量</span></span></span></p> 
          </blockquote> 
          <hr>
          <h2 id="Three" style="margin-left:0;"><a name="t24"></a><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">4.<a class="hl hl-1" href="https://so.csdn.net/so/search?q=%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&amp;spm=1001.2101.3001.7020" title="构造函数">构造函数</a></span></span></span></h2> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">4.1 无参的构造方法,创建一个容量为16的ArrayDeque</span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码如下：</span></span></span></p> 
          <pre class="has" style="margin-left:0;" data-index="0" name="code"><code class="language-prettyprint hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public ArrayDeque() {       //无参构造函数，默认的底层数组大小为16.</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        elements = new Object[16];</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">4.2 有参的构造方法，创建一个指定大小的ArrayDeque</span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码如下：</span></span></span></p> 
          <pre class="has set-code-hide" style="margin-left:0;" data-index="1" name="code"><code class="language-prettyprint hljs"><ol class="hljs-ln" style="width:753px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public ArrayDeque(int numElements) { //如果指定初始容量小于8，将会返回容量为8的新数组。</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        allocateElements(numElements);   //调用allocateElements方法，分配新数组</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    private void allocateElements(int numElements) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        int initialCapacity = MIN_INITIAL_CAPACITY;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        //做移位与运算最后加一得到比给定长度大的最小的2的幂数。</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        if (numElements &gt;= initialCapacity) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            initialCapacity = numElements;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  1);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  2);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  4);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  8);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            initialCapacity |= (initialCapacity &gt;&gt;&gt; 16);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            initialCapacity++;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            if (initialCapacity &lt; 0)   // Too many elements, must back off</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                initialCapacity &gt;&gt;&gt;= 1;// Good luck allocating 2 ^ 30 elements</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="20"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        elements = new Object[initialCapacity];</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="21"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li></ol></code><div class="hide-preCode-box"><span class="hide-preCode-bt" data-report-view="{&quot;spm&quot;:&quot;1001.2101.3001.7365&quot;}"><img class="look-more-preCode contentImg-no-view" src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png" alt="" title=""></span></div><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码分析：对于一个给定长度，先判断是否小于定义的最小长度，如果小于，则使用定义的最小长度作为数组的长度。否则，找到比给定长度大的最小的2的幂数（在if里面的语句实现这一功能）。</span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">如下图所示：</span></span></span></p> 
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><img alt="" src="https://img-blog.csdnimg.cn/img_convert/cd30da68ea2ebf1f7fe87bb9c2b41a25.png"></span></span></span></p> 
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><span style="color:#800080;">【注】 "&gt;&gt;&gt;"表示无符号右移，也叫逻辑右移。即若该数为正，则高位补0，若该数为负数，则右移后高位同样补0.</span></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">4.3 有参的构造方法，将现有集合元素C加入队列进行构造</span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码如下：</span></span></span></p> 
          <pre class="has set-code-hide" style="margin-left:0;" data-index="2" name="code"><code class="language-prettyprint hljs"><ol class="hljs-ln" style="width:852px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public ArrayDeque(Collection&lt;? extends E&gt; c) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        allocateElements(c.size());//调用上述allocateElements()方法，分配型数组内存空间。</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        addAll(c);//调用addAll()方法，将现有集合元素c添加到ArrayDeque中。</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">//addAll(Collection c) inherited from AbstractCollection</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public boolean addAll(Collection&lt;? extends E&gt; c) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        boolean modified = false;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        for (E e : c)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            if (add(e))</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                modified = true;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        return modified;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">//将集合元素添加到ArrayDeque末尾</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public boolean add(E e) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        addLast(e);//addLast()方法作用为：在最后一个元素后面添加元素。详见下述public void addLast(E e)。</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        return true;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }   </div></div></li></ol></code><div class="hide-preCode-box"><span class="hide-preCode-bt" data-report-view="{&quot;spm&quot;:&quot;1001.2101.3001.7365&quot;}"><img class="look-more-preCode contentImg-no-view" src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png" alt="" title=""></span></div><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <div style="margin-left:0;"></div> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码分析： 先根据已有集合c大小，通过allocateElement()方法创建最小的2的幂数的数组空间。addAll()将c中元素通过add()逐个添加到型数组中。</span></span></span></p> 
          <hr>
          <h2 id="Four" style="margin-left:0;"><a name="t25"></a><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">5.方法分析</span></span></span></h2> 
          <h3 id="Five" style="margin-left:0;"><a name="t26"></a><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">添加元素</span></span></span></h3> 
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><span style="color:#339933;">public void addFirst(E e)</span><br><span style="color:#ffa500;">作用:在ArrayDeque前面添加元素。</span></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码如下:</span></span></span></p> 
          <pre class="has set-code-hide" style="margin-left:0;" data-index="3" name="code"><code class="language-prettyprint hljs"><ol class="hljs-ln" style="width:913px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public void addFirst(E e) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        if (e == null)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            throw new NullPointerException();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        elements[head = (head - 1) &amp; (elements.length - 1)] = e;//将元素e添加到ArrayDeque双端队列的队首位置。</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        if (head == tail)//(head == tail)判定内存不足</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            doubleCapacity();//进行扩容操作</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">//扩容为原来的两倍</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    private void doubleCapacity() {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        assert head == tail;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        int p = head;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        int n = elements.length;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        int r = n - p; // number of elements to the right of p</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        int newCapacity = n &lt;&lt; 1;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        if (newCapacity &lt; 0)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            throw new IllegalStateException("Sorry, deque too big");</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        Object[] a = new Object[newCapacity];</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        System.arraycopy(elements, p, a, 0, r);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="20"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        System.arraycopy(elements, 0, a, r, p);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="21"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        elements = a;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="22"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        head = 0;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="23"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        tail = n;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="24"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="25"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="26"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    //java.lang.System</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="27"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">/*</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="28"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    @Function:复制数组，以插入元素，但是要将index之后的元素都往后移一位。然后就是插入元素，增加sized的值</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="29"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    @src:源数组  srcPos:源数组要复制的起始位置   dest:目的数组  destPos:目的数组放置的起始位置  length:复制的长度</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="30"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">*/</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="31"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public static native void arraycopy(Object src,int srcPos,Object dest, int destPosint length);</div></div></li></ol></code><div class="hide-preCode-box"><span class="hide-preCode-bt" data-report-view="{&quot;spm&quot;:&quot;1001.2101.3001.7365&quot;}"><img class="look-more-preCode contentImg-no-view" src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png" alt="" title=""></span></div><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <div style="margin-left:0;"></div> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码分析：将元素插入到head前一位，同时修改head值。判断内存是否足够，若不够，扩容为原数组的两倍。然后通过System.arraycopy()，将原来数组的元素复制到新数组中。</span></span></span></p> 
          <blockquote> 
           <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#555666;">elements[head = (head - 1) &amp; (elements.length - 1)] = e;</span></span></span></p> 
          </blockquote> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">当head ≠ 0时</span></span></span></p> 
          <span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;">因为element数组的内存大小为2的n次幂，因此(elements.length-1),二进制为全1，[head - 1] &amp; (elements.length - 1)]值始终为head-1的值。即在element[head-1]插入元素。</span></span> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">当head = 0时</span></span></span></p> 
          <span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;">head - 1 = -1。其中-1用二进制表示为全1，与elements.length - 1逐位与，结果为elements.length - 1的值，即在数组的末尾插入元素。</span></span> 
          <blockquote> 
           <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#555666;">System.arraycopy(elements, p, a, 0, r);<br> System.arraycopy(elements, 0, a, r, p);</span></span></span></p> 
          </blockquote> 
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">将elements数组从head索引(n-p)长度复制到a数组从0开始的位置。然后将elements数组从0索引开始p长度复制到a<a class="hl hl-1" href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&amp;spm=1001.2101.3001.7020" title="数组">数组</a>r索引开始的位置。</span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">如下图所示：</span></span></span></p> 
          <p style="margin-left:0;"></p> 
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><img alt="" src="https://img-blog.csdnimg.cn/img_convert/c5f4a869dd54a117ba835900a199a93a.png"></span></span></span></p> 
          <hr>
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><span style="color:#339933;">public void addLast(E e)</span><br><span style="color:#ffa500;">作用：在ArrayDeque后面添加元素。</span></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码如下：</span></span></span></p> 
          <pre class="has" style="margin-left:0;" data-index="4" name="code"><code class="language-prettyprint hljs"><ol class="hljs-ln" style="width:1241px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public void addLast(E e) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        if (e == null)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            throw new NullPointerException();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        elements[tail] = e;//将e放到tail位置</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head)//和head的操作类似，为了处理临界情况 (tail为length - 1时)，和length - 1进行与操作，结果为0</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            doubleCapacity();//将ArrayDeque容量扩展为原来的两倍。源码详见上述public void addFirst(E e)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }  </div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码分析： 在ArrayDeque中tail索引处添加元素e。若添加元素后tail+1 == head，判定内存不足，对ArrayDeque调用doubleCapacity()进行扩容操作。</span></span></span></p> 
          <hr>
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><span style="color:#339933;">public boolean offerFirst(E e)</span><br><span style="color:#ffa500;">作用：在ArrayDeque前添加一个元素，并返回是否添加成功。</span></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码如下：</span></span></span></p> 
          <pre class="has" style="margin-left:0;" data-index="5" name="code"><code class="language-prettyprint hljs"><ol class="hljs-ln" style="width:793px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public boolean offerFirst(E e) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        addFirst(e);//在ArrayDeque数组head前添加元素，addFirst()详见上述public void addFirst().</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        return true;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码分析： 调用addFirst()方法，当添加成功后返回true。</span></span></span></p> 
          <hr>
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><span style="color:#339933;">public boolean offerLast(Object o)</span><br><span style="color:#ffa500;">作用：在ArrayDeque后面添加一个元素，并返回是否添加成功。</span></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码如下：</span></span></span></p> 
          <pre class="has" style="margin-left:0;" data-index="6" name="code"><code class="language-prettyprint hljs"><ol class="hljs-ln" style="width:762px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public boolean offerLast(E e) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        addLast(e);//在ArrayDeque数组tail出添加元素，addLast()详见上述public void addLast()</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        return true;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码分析： 调用addLast()方法，当添加成功后返回true.</span></span></span></p> 
          <hr>
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><span style="color:#339933;">public E pollFirst()</span><br><span style="color:#ffa500;">作用：删除第一个元素，并返回删除元素的值。如果元素为null，将返回null.</span></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码如下：</span></span></span></p> 
          <pre class="has" style="margin-left:0;" data-index="7" name="code"><code class="language-prettyprint hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public E pollFirst() {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        int h = head;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        @SuppressWarnings("unchecked")</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        E result = (E) elements[h];</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        // Element is null if deque empty</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        if (result == null)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            return null;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        elements[h] = null;     // Must null out slot</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        head = (h + 1) &amp; (elements.length - 1);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        return result;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码分析： 将数组的第一个元素赋值给result并返回，同时将head后移。</span></span></span></p> 
          <hr>
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><span style="color:#339933;">public E removeFirst()</span><br><span style="color:#ffa500;">作用：删除第一个元素，并返回删除元素的值。如果元素为null，将抛出异常。</span></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码如下：</span></span></span></p> 
          <pre class="has" style="margin-left:0;" data-index="8" name="code"><code class="language-prettyprint hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public E removeFirst() {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        E x = pollFirst();//将删除后的值赋给x,pollFirst()详见上述pollFirst()</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        if (x == null)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            throw new NoSuchElementException();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        return x;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码分析： 调用pollFirst()返回删除的值，若返回值为null，抛出异常。</span></span></span></p> 
          <hr>
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><span style="color:#339933;">public E pollLast()</span><br><span style="color:#ffa500;">作用：删除最后一个元素，并返回删除元素的值。如果元素为null，将返回null。</span></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码如下：</span></span></span></p> 
          <pre class="has" style="margin-left:0;" data-index="9" name="code"><code class="language-prettyprint hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public E pollLast() {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        int t = (tail - 1) &amp; (elements.length - 1);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        @SuppressWarnings("unchecked")</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        E result = (E) elements[t];</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        if (result == null)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            return null;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        elements[t] = null;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        tail = t;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        return result;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码分析： (tail - 1) &amp; (elements.length - 1)指定待删除元素的位置，并将待删除元素赋值给result.同时将数组中最后一个元素赋null值。</span></span></span></p> 
          <hr>
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><span style="color:#339933;">public E removeLast()</span><br><span style="color:#ffa500;">作用：删除最后一个元素，并返回删除元素的值。如果元素为null，将抛出异常。</span></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码如下：</span></span></span></p> 
          <pre class="has" style="margin-left:0;" data-index="10" name="code"><code class="language-prettyprint hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public E removeLast() {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        E x = pollLast();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        if (x == null)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            throw new NoSuchElementException();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        return x;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码分析： 调用pollLast()返回删除的值，若返回值为null，抛出异常。</span></span></span></p> 
          <hr>
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><span style="color:#339933;">public boolean removeFirstOccurrence(Object o)</span><br><span style="color:#ffa500;">作用：删除第一次出现的指定元素。</span></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码如下：</span></span></span></p> 
          <pre class="has set-code-hide" style="margin-left:0;" data-index="11" name="code"><code class="language-prettyprint hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public boolean removeFirstOccurrence(Object o) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        if (o == null)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            return false;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        int mask = elements.length - 1;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        int i = head;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        Object x;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        while ( (x = elements[i]) != null) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            if (o.equals(x)) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                delete(i);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                return true;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            i = (i + 1) &amp; mask;//从头到尾遍历</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        return false;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li></ol></code><div class="hide-preCode-box"><span class="hide-preCode-bt" data-report-view="{&quot;spm&quot;:&quot;1001.2101.3001.7365&quot;}"><img class="look-more-preCode contentImg-no-view" src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png" alt="" title=""></span></div><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码分析：</span></span></span></p> 
          <blockquote> 
           <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#555666;">i = (i + 1) &amp; mask;</span></span></span></p> 
          </blockquote> 
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">对数组从头到尾进行遍历，</span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">原理如下图所示：</span></span></span></p> 
          <p style="margin-left:0;"></p> 
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><img alt="" src="https://img-blog.csdnimg.cn/img_convert/969f2b3ad774e633cf539353ed60c03f.png"></span></span></span></p> 
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">从数组的head处对非空元素进行遍历，若数组中包含o对象，调用delete()进行删除，并返回true；否则，返回false。</span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">private boolean delete(int i)源码如下所示：</span></span></span></p> 
          <pre class="has set-code-hide" style="margin-left:0;" data-index="12" name="code"><code class="language-prettyprint hljs"><ol class="hljs-ln" style="width:1099px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    private void checkInvariants() {//有效性检查</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        assert elements[tail] == null;//tail位置没有元素</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        assert head == tail ? elements[head] == null :</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            (elements[head] != null &amp;&amp;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">             elements[(tail - 1) &amp; (elements.length - 1)] != null);//如果head和tail重叠，队列为空；否则heaed位置有元素，tail-1位置有元素</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        assert elements[(head - 1) &amp; (elements.length - 1)] == null;//head-1 的位置没有元素</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    private boolean delete(int i) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        checkInvariants();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        final Object[] elements = this.elements;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        final int mask = elements.length - 1;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        final int h = head;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        final int t = tail;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        final int front = (i - h) &amp; mask;//i到head元素处之间的元素个数</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        final int back  = (t - i) &amp; mask;//i到tail元素处之间的元素个数</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        // Invariant: head &lt;= i &lt; tail mod circularity</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="20"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        if (front &gt;= ((t - h) &amp; mask))//i到head元素处的距离大于现有元素总数，抛出异常</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="21"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            throw new ConcurrentModificationException();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="22"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="23"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        // Optimize for least element motion</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="24"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        if (front &lt; back) {//i的元素靠近head,移动开始的元素，返回false.</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="25"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            if (h &lt;= i) {//当i在head的后面</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="26"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                //将从head开始长度为front的数组片段复制到head+1开始的地方</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="27"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                System.arraycopy(elements, h, elements, h + 1, front);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="28"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            } else { // 当i在head的前面</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="29"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                //将0 ~ （i - 1)的元素后移一位，将数组最后一位元素移到数组第一位，将head后的元素后移一位。</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="30"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                System.arraycopy(elements, 0, elements, 1, i);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="31"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                elements[0] = elements[mask];</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="32"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                System.arraycopy(elements, h, elements, h + 1, mask - h);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="33"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="34"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            elements[h] = null;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="35"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            head = (h + 1) &amp; mask;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="36"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            return false;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="37"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        } else {//i的位置靠近tail，移动末尾的元素，返回true.</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="38"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            if (i &lt; t) { 当i在tail的前面</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="39"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                //将从i + 1开始长度为back的数组片段复制到以i开始的地方</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="40"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                System.arraycopy(elements, i + 1, elements, i, back);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="41"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                tail = t - 1; </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="42"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            } else { //当i在tail后面</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="43"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                //将从i+1到数组最后一个元素往前移动一位，再将第一个元素移到最后一位。将剩余元素往前移动一位</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="44"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                System.arraycopy(elements, i + 1, elements, i, mask - i);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="45"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                elements[mask] = elements[0];</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="46"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                System.arraycopy(elements, 1, elements, 0, t);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="47"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                tail = (t - 1) &amp; mask;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="48"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="49"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            return true;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="50"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="51"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li></ol></code><div class="hide-preCode-box"><span class="hide-preCode-bt" data-report-view="{&quot;spm&quot;:&quot;1001.2101.3001.7365&quot;}"><img class="look-more-preCode contentImg-no-view" src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png" alt="" title=""></span></div><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <div style="margin-left:0;"></div> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码分析： 为了算法的复杂度，将delete()函数分为三种情况</span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">如下图所示：</span></span></span></p> 
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><img alt="" src="https://img-blog.csdnimg.cn/img_convert/1af39bb6165bcdb36cec24d28112f8ee.png"></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">一.待删除元素距离第一个元素比最后一个元素近</span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">1.1 待删除元素在数组中的位置在第一个元素的后面</span></span></span></p> 
          <span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;">将从head开始长度为front的数组片段复制到head+1开始的地方。如下图所示：</span></span> 
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><img alt="" src="https://img-blog.csdnimg.cn/img_convert/b9d74e218cc61c1028486497fc00df63.png"></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">1.2 待删除元素在数组中的位置在第一个元素的前面</span></span></span></p> 
          <span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;">将0 ~ （i - 1)的元素后移一位，将数组最后一位元素移到数组第一位，将head后的元素后移一位。如下图所示：</span></span> 
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><img alt="" src="https://img-blog.csdnimg.cn/img_convert/e26b2cd541c300479bed8c0e3519b80d.png"></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">二.待删除元素距离最后一个元素比第一个元素近</span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">2.1 待删除元素在数组中的位置在第一个元素的前面</span></span></span></p> 
          <span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;">将从i + 1开始长度为back的数组片段复制到以i开始的地方。如下图所示：</span></span> 
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><img alt="" src="https://img-blog.csdnimg.cn/img_convert/368eff3d2dd28e73a68236cb243c3217.png"></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">2.2 待删除元素在数组中的位置在第一个元素的后面</span></span></span></p> 
          <span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;">将从i+1到数组最后一个元素往前移动一位，再将第一个元素移到最后一位。将剩余元素往前移动一位。如下图所示：</span></span> 
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><img alt="" src="https://img-blog.csdnimg.cn/img_convert/d4db1fe4f40ff05e29dbdf25bbc4ad11.png"></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">三.待删除元素到第一个元素的距离等于到最后一个元素的距离</span></span></span></p> 
          <span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;">同情况二。</span></span> 
          <hr>
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><span style="color:#339933;">public boolean removeLastOccurrence(Object o)</span><br><span style="color:#ffa500;">作用：删除最后一次出现的指定元素。</span></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码如下：</span></span></span></p> 
          <pre class="has set-code-hide" style="margin-left:0;" data-index="13" name="code"><code class="language-prettyprint hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public boolean removeLastOccurrence(Object o) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        if (o == null)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            return false;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        int mask = elements.length - 1;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        int i = (tail - 1) &amp; mask;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        Object x;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        while ( (x = elements[i]) != null) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            if (o.equals(x)) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                delete(i);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                return true;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            i = (i - 1) &amp; mask;//从尾到头遍历</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        return false;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li></ol></code><div class="hide-preCode-box"><span class="hide-preCode-bt" data-report-view="{&quot;spm&quot;:&quot;1001.2101.3001.7365&quot;}"><img class="look-more-preCode contentImg-no-view" src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png" alt="" title=""></span></div><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码分析： 从最后一个元素处对数组进行遍历，若数组中包含o对象，调用delete()进行删除，并返回true；否则，返回false。原理同上述public boolean removeFirstOccurrence(Object o)。</span></span></span></p> 
          <hr>
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><span style="color:#339933;">public E getFirst()</span><br><span style="color:#ffa500;">作用：获取第一个元素，如果没有将抛出异常。</span></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码如下：</span></span></span></p> 
          <pre class="has" style="margin-left:0;" data-index="14" name="code"><code class="language-prettyprint hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public E getFirst() {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        @SuppressWarnings("unchecked")</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        E result = (E) elements[head];</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        if (result == null)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            throw new NoSuchElementException();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        return result;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码分析： 将head索引处元素值返回。</span></span></span></p> 
          <hr>
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><span style="color:#339933;">public E getLast()</span><br><span style="color:#ffa500;">作用：获取最后一个元素，如果没有将抛出异常。</span></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码如下：</span></span></span></p> 
          <pre class="has" style="margin-left:0;" data-index="15" name="code"><code class="language-prettyprint hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public E getLast() {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        @SuppressWarnings("unchecked")</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        E result = (E) elements[(tail - 1) &amp; (elements.length - 1)];</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        if (result == null)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            throw new NoSuchElementException();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        return result;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码分析： 将最后一个元素值返回。</span></span></span></p> 
          <hr>
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><span style="color:#339933;">public boolean add(E e)</span><br><span style="color:#ffa500;">作用：在队列尾部添加一个元素。</span></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码如下：</span></span></span></p> 
          <pre class="has" style="margin-left:0;" data-index="16" name="code"><code class="language-prettyprint hljs"><ol class="hljs-ln" style="width:852px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public boolean add(E e) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        addLast(e);//addLast()方法作用为：在最后一个元素后面添加元素。详见下述public void addLast(E e)。</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        return true;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <hr>
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><span style="color:#339933;">public boolean offer(E e)</span><br><span style="color:#ffa500;">作用：在队列尾部添加一个元素，并返回是否成功</span></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码如下：</span></span></span></p> 
          <pre class="has" style="margin-left:0;" data-index="17" name="code"><code class="language-prettyprint hljs"><ol class="hljs-ln" style="width:767px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public boolean offer(E e) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        return offerLast(e);//offerLast()源码分析详见上述public boolean offerLast(Object o)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <hr>
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><span style="color:#339933;">public E remove()</span><br><span style="color:#ffa500;">作用：删除队列中第一个元素，并返回该元素的值，如果元素为null，将抛出异常(其实底层调用的是removeFirst())</span></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码如下：</span></span></span></p> 
          <pre class="has" style="margin-left:0;" data-index="18" name="code"><code class="language-prettyprint hljs"><ol class="hljs-ln" style="width:857px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public E remove() {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        return removeFirst();//移除队列第一个元素。removeFirst()源码分析详见上述：public E removeFirst()</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <hr>
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><span style="color:#339933;">public E poll()</span><br><span style="color:#ffa500;">作用：删除队列中第一个元素，并返回该元素的值，如果元素为null，将返回null。</span></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码如下：</span></span></span></p> 
          <pre class="has" style="margin-left:0;" data-index="19" name="code"><code class="language-prettyprint hljs"><ol class="hljs-ln" style="width:906px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public E poll() {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        return pollFirst();//删除第一个元素，并返回删除元素的值.pollFirst()源码分析详见上述public E pollFirst()</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <hr>
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><span style="color:#339933;">public E element()</span><br><span style="color:#ffa500;">作用：获取第一个元素。如果没有将抛出异常</span></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码如下：</span></span></span></p> 
          <pre class="has" style="margin-left:0;" data-index="20" name="code"><code class="language-prettyprint hljs"><ol class="hljs-ln" style="width:774px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public E element() {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        return getFirst();//getFirst()用于获取第一个元素， 源码详见上述： public E getFirst()</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <hr>
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><span style="color:#339933;">public E peek()</span><br><span style="color:#ffa500;">作用：获取第一个元素，如果返回null.</span></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码如下：</span></span></span></p> 
          <pre class="has" style="margin-left:0;" data-index="21" name="code"><code class="language-prettyprint hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public E peek() {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        return peekFirst();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public E peekFirst() {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        // elements[head] is null if deque empty</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        return (E) elements[head];</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <hr>
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><span style="color:#339933;">public void push(E e)</span><br><span style="color:#ffa500;">作用：栈顶添加一个元素.</span></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码如下：</span></span></span></p> 
          <pre class="has" style="margin-left:0;" data-index="22" name="code"><code class="language-prettyprint hljs"><ol class="hljs-ln" style="width:830px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public void push(E e) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        addFirst(e);//在head索引前添加元素，并将head前移。源码分析详见上述：public void addFirst(E e)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <hr>
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><span style="color:#339933;">public E pop()</span><br><span style="color:#ffa500;">作用：栈顶添加一个元素.</span></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码如下：</span></span></span></p> 
          <pre class="has" style="margin-left:0;" data-index="23" name="code"><code class="language-prettyprint hljs"><ol class="hljs-ln" style="width:873px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public E pop() {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        return removeFirst();//删除第一个元素，并返回删除元素的值。源码分析详见上述：public E removeFirst()</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <hr>
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><span style="color:#339933;">public int size()</span><br><span style="color:#ffa500;">作用：获取队列中元素个数.</span></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码如下：</span></span></span></p> 
          <pre class="has" style="margin-left:0;" data-index="24" name="code"><code class="language-prettyprint hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public int size() {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        return (tail - head) &amp; (elements.length - 1);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码分析： 当tail在数组中的位置在head的后面(tail - head) &amp; (elements.length - 1) 等价于 (tail - head)。当tail在数组中的位置在head的前面(tail - head) &amp; (elements.length - 1) 等价于 elements - (tail - head)。</span></span></span></p> 
          <hr>
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><span style="color:#339933;">public boolean isEmpty()</span><br><span style="color:#ffa500;">作用：判断队列是否为空。</span></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码如下：</span></span></span></p> 
          <pre class="has" style="margin-left:0;" data-index="25" name="code"><code class="language-prettyprint hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public boolean isEmpty() {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        return head == tail;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码分析： tail位置的元素一定为空，head和tail相等，也为空。</span></span></span></p> 
          <hr>
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><span style="color:#339933;">public Iterator iterator()</span><br><span style="color:#ffa500;">作用：迭代器，从前往后迭代</span></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码如下：</span></span></span></p> 
          <pre class="has set-code-hide" style="margin-left:0;" data-index="26" name="code"><code class="language-prettyprint hljs"><ol class="hljs-ln" style="width:811px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public Iterator&lt;E&gt; iterator() {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        return new DeqIterator();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    private class DeqIterator implements Iterator&lt;E&gt; {  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      private int cursor = head;  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      private int fence = tail; // 迭代终止索引，同时也为了检测并发修改。  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      private int lastRet = -1; // 最近的next()调用返回的索引。据此可以定位到需要删除元素的位置。  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      public boolean hasNext() {  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">          return cursor != fence;  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      }  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      public E next() {  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">          if (cursor == fence)  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">              throw new NoSuchElementException();  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">          E result = elements[cursor];  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">          // This check doesn't catch all possible comodifications,  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">          // but does catch the ones that corrupt traversal  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">          if (tail != fence || result == null)  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="20"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">              throw new ConcurrentModificationException();  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="21"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">          lastRet = cursor;  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="22"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">          cursor = (cursor + 1) &amp; (elements.length - 1); // 游标位置加1  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="23"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">          return result;  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="24"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      }  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="25"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="26"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      public void remove() {  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="27"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">          if (lastRet &lt; 0)  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="28"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">              throw new IllegalStateException();  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="29"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">          if (delete(lastRet)) { // 如果将元素从右往左移，需要将游标减1。  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="30"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">              cursor = (cursor - 1) &amp; (elements.length - 1); // 游标位置回退1。  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="31"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">fence = tail; // 重置阀值。  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="32"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   }  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="33"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">          lastRet = -1;  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="34"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      }  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="35"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  }  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="36"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li></ol></code><div class="hide-preCode-box"><span class="hide-preCode-bt" data-report-view="{&quot;spm&quot;:&quot;1001.2101.3001.7365&quot;}"><img class="look-more-preCode contentImg-no-view" src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png" alt="" title=""></span></div><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <div style="margin-left:0;"></div> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码分析： ArrayDeque继承了Iterable接口，必须实现其中的iterator()，ArrayDeque实现从头往后遍历的迭代器iterator()，其中主要包含：hasNext()方法用于判定当前cursor是否还有下一个元素；next()方法来锁定下一个元素；以及remove()用于移除lastRet处的元素值。</span></span></span></p> 
          <hr>
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><span style="color:#339933;">public Iterator descendingIterator()</span><br><span style="color:#ffa500;">作用：迭代器，从后向前迭代</span></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码如下：</span></span></span></p> 
          <pre class="has set-code-hide" style="margin-left:0;" data-index="27" name="code"><code class="language-prettyprint hljs"><ol class="hljs-ln" style="width:953px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public Iterator&lt;E&gt; descendingIterator() {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        return new DescendingIterator();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }       </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    private class DescendingIterator implements Iterator&lt;E&gt; {  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        private int cursor = tail; // 游标开始索引为tail  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        private int fence = head; // 游标的阀值为head  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        private int lastRet = -1;  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        public boolean hasNext() {  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            return cursor != fence;  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        }  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        public E next() {  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            if (cursor == fence)  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                throw new NoSuchElementException();  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            cursor = (cursor - 1) &amp; (elements.length - 1); // tail是下个添加元素的位置，所以要减1才是尾节点的索引。  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            E result = elements[cursor];  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="20"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            if (head != fence || result == null)  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="21"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                throw new ConcurrentModificationException();  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="22"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            lastRet = cursor;  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="23"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            return result;  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="24"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        }  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="25"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="26"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        public void remove() {  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="27"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            if (lastRet &lt; 0)  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="28"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                throw new IllegalStateException();  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="29"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            if (!delete(lastRet)) { // 如果从左往右移，需要将游标加1。  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="30"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                cursor = (cursor + 1) &amp; (elements.length - 1);  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="31"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                fence = head;  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="32"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            }  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="33"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            lastRet = -1;  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="34"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        }  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="35"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }  </div></div></li></ol></code><div class="hide-preCode-box"><span class="hide-preCode-bt" data-report-view="{&quot;spm&quot;:&quot;1001.2101.3001.7365&quot;}"><img class="look-more-preCode contentImg-no-view" src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png" alt="" title=""></span></div><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <div style="margin-left:0;"></div> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码分析： DescendingIterator是从后往前的迭代器。其中主要包含：hasNext()方法用于判定当前cursor是否还有下一个元素；next()方法来锁定下一个元素；以及remove()用于移除lastRet处的元素值。</span></span></span></p> 
          <hr>
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><span style="color:#339933;">public boolean contains(Object o)</span><br><span style="color:#ffa500;">作用：判断队列中是否存在钙元素。</span></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码如下：</span></span></span></p> 
          <pre class="has" style="margin-left:0;" data-index="28" name="code"><code class="language-prettyprint hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public boolean contains(Object o) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        if (o == null)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            return false;//ArrayDeque不能存储null值</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        int mask = elements.length - 1;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        int i = head;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        Object x;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        while ( (x = elements[i]) != null) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            if (o.equals(x))</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                return true;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            i = (i + 1) &amp; mask;//处理临界情况</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        return false;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码分析： 同上述：public boolean removeFirstOccurrence(Object o),从前往后遍历，如果在数组中存在与o相同的元素，则返回true。否则，返回false。</span></span></span></p> 
          <hr>
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><span style="color:#339933;">public Object[] toArray()</span><br><span style="color:#ffa500;">作用：转成数组。</span></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码如下：</span></span></span></p> 
          <pre class="has" style="margin-left:0;" data-index="29" name="code"><code class="language-prettyprint hljs"><ol class="hljs-ln" style="width:1015px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public Object[] toArray() {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        return copyElements(new Object[size()]);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    private &lt;T&gt; T[] copyElements(T[] a) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        if (head &lt; tail) {//将elements数组所有元素复制到从0索引开始的a数组中</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            System.arraycopy(elements, head, a, 0, size());</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        } else if (head &gt; tail) {//先复制从elements数组head~elements.length - 1处数组，然后将0 ~ tail - 1索引处元素复制到后面</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            int headPortionLen = elements.length - head;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            System.arraycopy(elements, head, a, 0, headPortionLen);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            System.arraycopy(elements, 0, a, headPortionLen, tail);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        return a;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码分析： 把所有元素拷贝到新创建的Object数组上，所以对返回数组的修改不会影响该双端队列。</span></span></span></p> 
          <hr>
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><span style="color:#339933;">public T[] toArray(T[] a)</span><br><span style="color:#ffa500;">作用：转成指定数组。</span></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码如下：</span></span></span></p> 
          <pre class="has" style="margin-left:0;" data-index="30" name="code"><code class="language-prettyprint hljs"><ol class="hljs-ln" style="width:814px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public &lt;T&gt; T[] toArray(T[] a) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        int size = size();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        if (a.length &lt; size)//目标数组大小不够</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            a = (T[])java.lang.reflect.Array.newInstance(</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                    a.getClass().getComponentType(), size);//利用反射创建类型为T，大小为size的数组</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        copyElements(a);//拷贝所有元素到目标数组。源码详见上述：&gt;public Object[] toArray()</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        if (a.length &gt; size)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            a[size] = null;//结束标识</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        return a;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码分析：</span></span></span></p> 
          <blockquote> 
           <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#555666;">a = (T[])java.lang.reflect.Array.newInstance(a.getClass().getComponentType(), size);</span></span></span></p> 
          </blockquote> 
          <hr>
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><span style="color:#339933;">public void clear()</span><br><span style="color:#ffa500;">作用：清空队列。</span></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码如下：</span></span></span></p> 
          <pre class="has" style="margin-left:0;" data-index="31" name="code"><code class="language-prettyprint hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public void clear() {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        int h = head;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        int t = tail;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        if (h != t) { // 判空条件</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            head = tail = 0;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            int i = h;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            int mask = elements.length - 1;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            do {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                elements[i] = null;//清除元素</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                i = (i + 1) &amp; mask;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            } while (i != t);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码分析： 从前往后将数组值置空值。</span></span></span></p> 
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><span style="color:#339933;">public ArrayDeque clone()</span><br><span style="color:#ffa500;">作用：克隆(复制)一个新的队列。</span></span></span></span></p> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码如下：</span></span></span></p> 
          <pre class="has" style="margin-left:0;" data-index="32" name="code"><code class="language-prettyprint hljs"><ol class="hljs-ln" style="width:694px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    public ArrayDeque&lt;E&gt; clone() {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        try {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            @SuppressWarnings("unchecked")</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            ArrayDeque&lt;E&gt; result = (ArrayDeque&lt;E&gt;) super.clone();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            //传入elements数组与数组长度返回一个新数组。</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            result.elements = Arrays.copyOf(elements, elements.length);//深度复制</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            return result;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        } catch (CloneNotSupportedException e) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            throw new AssertionError();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">源码分析： ArrayDeque类实现了Cloneable接口，可以通过super调用父类Object的clone()，克隆后result指向ArrayDeque队列。</span></span></span></p> 
          <hr>
          <h2 id="Nine" style="margin-left:0;"><a name="t27"></a><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">6.参考资料</span></span></span></h2> 
          <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><a href="https://zhuanlan.zhihu.com/p/64270911" title="死磕 java集合之ArrayDeque源码分析">死磕 java集合之ArrayDeque源码分析</a><br><a href="https://skaygo.blog.csdn.net/article/details/74840513?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.control" title="ArrayDeque类的使用详解">ArrayDeque类的使用详解</a></span></span></span></p> 
          <p style="margin-left:0;"></p> 
          <blockquote> 
           <h1 style="margin-left:0px;"><a name="t28"></a>三：栈Stack</h1> 
          </blockquote> 
          <h2><a name="t29"></a><strong><a id="_2"></a>1、栈的理解</strong></h2> 
          <p>栈（Stack）是一种受限的线性<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;spm=1001.2101.3001.7020" title="数据结构">数据结构</a>，所谓受限是指栈只暴露栈顶和栈底的操作，其底层是由数组实现的。栈的特性是先进后出，类似于手枪压弹，原理示意图如下：<br><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/960d85001a3540a4a48d874cc908f75c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQXJjaGll5pWy6ZSu55uY,size_11,color_FFFFFF,t_70,g_se,x_16"></p> 
          <h2><a name="t30"></a><a id="Stack_5"></a>2、Stack的继承关系</h2> 
          <p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/576038c5a3c94ee386f39a27d5e50b5c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQXJjaGll5pWy6ZSu55uY,size_18,color_FFFFFF,t_70,g_se,x_16"></p> 
          <h2><a name="t31"></a><a id="Stack_8"></a>3、被弃用的Stack</h2> 
          <h3><a name="t32"></a><a id="31__9"></a>3.1 被弃用的原因</h3> 
          <p>从继承关系中，我们可以看到Stack的基本方法与底层实现，由于Vector是动态数组接口，其底层的实现是数组，因此，Stack的底层实现也是数组，且继承了Vector的公共方法。<br> 从前文（<a href="https://blog.csdn.net/Archiea/article/details/122576607" title="简析Vector类">简析Vector类</a>）我们知道，Vector类具有动态扩容和随机访问的特性，因此，继承了Vector类的Stack也同样具有这些特性，这恰好违背了Stack数据结构的设计原理，正因为如此，Java中的Stack一直被认为是糟糕的实现，官方也将Stack标志为“弃用”（deprecated）。<br> 综上所述，导致Stack糟糕实现的原因是Stack与Vector类的关系出现了错误，不应该是继承关系（is-a），而应是组合关系（has-a）。</p> 
          <h3><a name="t33"></a><a id="32__13"></a>3.2 如何替代</h3> 
          <p><span style="color:#fe2c24;"><strong>官方推荐使用Deque（双端队列）接口来实现Stack：</strong></span></p> 
          <pre data-index="33"><code class="hljs language-cobol"><span class="hljs-comment">Deque</span><span class="hljs-operator">&lt;</span>E<span class="hljs-operator">&gt;</span> stack <span class="hljs-operator">=</span> new ArrayDeque<span class="hljs-operator">&lt;&gt;</span>();
</code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <p>虽然官方做出了推荐，但是我们仍然可以发现，Deque实现的Stack实质是一个双端<a href="https://so.csdn.net/so/search?q=%E9%98%9F%E5%88%97&amp;spm=1001.2101.3001.7020" title="队列">队列</a>，可以在队列的两端实现插入和删除操作，仍然破坏力了封装性，并不安全，可以看出这并不是一个完美的方法。<br> 因此，在实际中更推荐大家再做一层封装，通过逻辑限定为只能一端操作插入和删除，形成一个真正的栈。</p> 
          <h3><a name="t34"></a><a id="33__21"></a>3.3 队列实现栈</h3> 
          <p>用队列实现栈，只需要⼀个队列作为底层数据结构。<br> 要实现的栈的API如下：</p> 
          <pre data-index="34"><code class="hljs language-csharp"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span> {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	<span class="hljs-comment">/** 添加元素到栈顶 */</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	<span class="hljs-comment">/** 删除栈顶的元素并返回 */</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">pop</span>()</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	<span class="hljs-comment">/** 返回栈顶元素 */</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">top</span>()</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	<span class="hljs-comment">/** 判断栈是否为空 */</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	<span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">empty</span>()</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">}</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <p>先说 push API，直接将元素加⼊队列，同时记录队尾元素，因为队尾元素相当于栈顶元素，如果要 top 查<br> 看栈顶元素的话可以直接返回：</p> 
          <pre data-index="35"><code class="hljs language-cobol"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">class </span>MyStack {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	Queue<span class="hljs-operator">&lt;</span>Integer<span class="hljs-operator">&gt;</span> q <span class="hljs-operator">=</span> new LinkedList<span class="hljs-operator">&lt;&gt;</span>();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	int <span class="hljs-keyword">top</span>_elem <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	<span class="hljs-operator">/</span><span class="hljs-operator">**</span> 添加元素到栈顶 <span class="hljs-operator">*</span><span class="hljs-operator">/</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	public void push(int x) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">		<span class="hljs-operator">/</span><span class="hljs-operator">/</span> x 是队列的队尾，是栈的栈顶</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">		q.offer(x);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">		<span class="hljs-keyword">top</span>_elem <span class="hljs-operator">=</span> x;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	}</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	<span class="hljs-operator">/</span><span class="hljs-operator">**</span> 返回栈顶元素 <span class="hljs-operator">*</span><span class="hljs-operator">/</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	public int <span class="hljs-keyword">top</span>() {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">		<span class="hljs-keyword">return</span> <span class="hljs-keyword">top</span>_elem;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	}</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">}</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <p>我们的底层数据结构是先进先出的队列，每次 pop 只能从队头取元素；但是栈是后进先出，也就是说 pop<br> API 要从队尾取元素：<br><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/74c3ce0b6a0449f3b1688d1411ce0426.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQXJjaGll5pWy6ZSu55uY,size_13,color_FFFFFF,t_70,g_se,x_16"><br> 解决⽅法简单粗暴，把队列前⾯的都取出来再加⼊队尾，让之前的队尾元素排到队头，这样就可以取出了：<br><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/5d9468f013724508800bc4a816a54eeb.png"></p> 
          <pre data-index="36"><code class="hljs language-cobol"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-operator">/</span><span class="hljs-operator">**</span> 删除栈顶的元素并返回 <span class="hljs-operator">*</span><span class="hljs-operator">/</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">public</span> int pop() {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	int <span class="hljs-keyword">size</span> <span class="hljs-operator">=</span> q.<span class="hljs-keyword">size</span>();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	while (<span class="hljs-keyword">size</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">		<span class="hljs-keyword">size</span>--;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	}</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	<span class="hljs-operator">/</span><span class="hljs-operator">/</span> 之前的队尾元素已经到了队头</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	<span class="hljs-keyword">return</span> q.poll();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">}</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <p>这样实现还有⼀点⼩问题就是，原来的队尾元素被提到队头并删除了，但是 top_elem 变量没有更新，我们<br> 还需要⼀点⼩修改：</p> 
          <pre data-index="37"><code class="hljs language-cobol"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-operator">/</span><span class="hljs-operator">**</span> 删除栈顶的元素并返回 <span class="hljs-operator">*</span><span class="hljs-operator">/</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">public</span> int pop() {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	int <span class="hljs-keyword">size</span> <span class="hljs-operator">=</span> q.<span class="hljs-keyword">size</span>();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	<span class="hljs-operator">/</span><span class="hljs-operator">/</span> 留下队尾 <span class="hljs-number">2</span> 个元素</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	while (<span class="hljs-keyword">size</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">2</span>) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">		q.offer(q.poll());</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">		<span class="hljs-keyword">size</span>--;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	}</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	<span class="hljs-operator">/</span><span class="hljs-operator">/</span> 记录新的队尾元素</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	<span class="hljs-keyword">top</span>_elem <span class="hljs-operator">=</span> q.peek();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	q.offer(q.poll());</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	<span class="hljs-operator">/</span><span class="hljs-operator">/</span> 删除之前的队尾元素</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	<span class="hljs-keyword">return</span> q.poll();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">}</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <p>最后，API empty 就很容易实现了，只要看底层的队列是否为空即可：</p> 
          <pre data-index="38"><code class="hljs language-cobol"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-operator">/</span><span class="hljs-operator">**</span> 判断栈是否为空 <span class="hljs-operator">*</span><span class="hljs-operator">/</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">public</span> <span class="hljs-keyword">boolean</span> empty() {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	<span class="hljs-keyword">return</span> q.isEmpty();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">}</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre> 
          <p>很明显，⽤队列实现栈的话，pop 操作时间复杂度是 O(N)，其他操作都是 O(1) 。</p> 
          <h3><a name="t35"></a><a id="34_Stack_102"></a>3.4 面试中的Stack</h3> 
          <p>如果面试中关注的是算法和程序的逻辑，那么数据结构的使用就不是重点，但是如果能用Deque实现，那自然是更好，尤其是需要考察对Java原因的理解。</p> 
         </div> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
  </div> 
 </div> 
</div>
                </div><div data-report-view="{&quot;mod&quot;:&quot;1585297308_001&quot;,&quot;spm&quot;:&quot;1001.2101.3001.6548&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/weixin_45433031/article/details/123747691&quot;,&quot;extend1&quot;:&quot;pc&quot;,&quot;ab&quot;:&quot;new&quot;}"><div></div></div>
        </div>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java开发]]></title>
        <id>https://RenzoWang.github.io/Notes.github.io/post/java-kai-fa/</id>
        <link href="https://RenzoWang.github.io/Notes.github.io/post/java-kai-fa/">
        </link>
        <updated>2022-07-14T01:40:15.000Z</updated>
        <summary type="html"><![CDATA[<!-- more -->
<p>Java日常开发记录</p>
]]></summary>
        <content type="html"><![CDATA[<!-- more -->
<p>Java日常开发记录</p>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Error [Makefile] make: "*" is up to date]]></title>
        <id>https://RenzoWang.github.io/Notes.github.io/post/error-makefile-make-is-up-to-date/</id>
        <link href="https://RenzoWang.github.io/Notes.github.io/post/error-makefile-make-is-up-to-date/">
        </link>
        <updated>2021-10-12T13:21:51.000Z</updated>
        <content type="html"><![CDATA[<p>原因：Makefile的目标target和当前目录下的某个文件名字冲突</p>
<p>解决方法：</p>
<p>比如是pstree这个名字冲突了</p>
<p>在Makefile中在pstree：</p>
<p>.PHONY:pstree</p>
<p>即可</p>
<p>这里是用来让系统不要认为clean是一个文件（因为输入语句后会检测同级目录下有没有同名文件），用.PHONY意思是不是文件</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[top-level const & low-level const]]></title>
        <id>https://RenzoWang.github.io/Notes.github.io/post/top-level-const-and-low-level-const/</id>
        <link href="https://RenzoWang.github.io/Notes.github.io/post/top-level-const-and-low-level-const/">
        </link>
        <updated>2021-05-09T07:57:12.000Z</updated>
        <content type="html"><![CDATA[<h3 id="top-level-const-low-level-const">top-level const &amp; low-level const</h3>
<p>top-level const to indicate that the pointer itself is a const. When a pointer can point to a const object, we refer tothat const as a low-level const.</p>
<ul>
<li>
<p>一般的变量来说，其实没有顶层const和底层const的区别<br>
1.一个指针本身添加const限定符就是顶层const。（指针被限定则 顶）<br>
　　　　　　　　　　　　　　　　  2.而指针所指的对象添加const限定符就是底层const。（对象被限则 底）</p>
</li>
<li>
<p>执行对象拷贝时有限制，常量的底层const不能赋值给非常量的底层const。</p>
</li>
</ul>
<pre><code class="language-cpp">int num_c = 3;  
const int *p_c = &amp;num_c;  //p_c为底层const的指针     还有一点记住  就是不能通过p_c去修改变量的值
//int *p_d = p_c;  //错误，不能将底层const指针赋值给非底层const指针  
const int *p_d = p_c; //正确，可以将底层const指针复制给底层const指针  
</code></pre>
<ul>
<li>使用命名的强制类型转换函数const_cast时，需要能够分辨底层const和顶层const，因为const_cast只能改变运算对象的底层const</li>
</ul>
<pre><code class="language-cpp">int num_e = 4;  
const int *p_e = &amp;num_e;  
//*p_e = 5;  //错误，不能改变底层const指针指向的内容  
int *p_f = const_cast&lt;int *&gt;(p_e);  //正确，const_cast可以改变运算对象的底层const。但是使用时一定要知道num_e不是const的类型。  
*p_f = 5;  //正确，非顶层const指针可以改变指向的内容  
cout &lt;&lt; num_e;  //输出5 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android Project]]></title>
        <id>https://RenzoWang.github.io/Notes.github.io/post/android-project/</id>
        <link href="https://RenzoWang.github.io/Notes.github.io/post/android-project/">
        </link>
        <updated>2021-04-16T12:35:28.000Z</updated>
        <summary type="html"><![CDATA[<p>A lite project for IM Chat App</p>
]]></summary>
        <content type="html"><![CDATA[<p>A lite project for IM Chat App</p>
<!-- more -->
<p><a href="https://github.com/RenzoWang/iems5722">Here</a> is the code</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[for vs. while in C programming]]></title>
        <id>https://RenzoWang.github.io/Notes.github.io/post/for-vs-while-in-c-programming/</id>
        <link href="https://RenzoWang.github.io/Notes.github.io/post/for-vs-while-in-c-programming/">
        </link>
        <updated>2021-04-16T07:53:42.000Z</updated>
        <content type="html"><![CDATA[<p>There are three loops in C: <code>for</code>, <code>while</code>, and <code>do-while</code>. What's the difference between them?  <a href="https://stackoverflow.com/questions/2950931/for-vs-while-in-c-programming">Answer</a></p>
<p>A <strong>while loop</strong> will always evaluate the condition first.</p>
<pre><code>while (condition) {
  //gets executed after condition is checked
}
</code></pre>
<p>A <strong>do/while loop</strong> will always execute the code in the <strong>do{}</strong> block first and then evaluate the condition.</p>
<pre><code>do {
  //gets executed at least once
} while
</code></pre>
<p>A <strong>for</strong> loop allows you to initiate a counter variable, a check condition, and a way to increment your counter all in one line.</p>
<pre><code>for (int x = 0; x &lt; 100; x++) {
   //executed until x &gt;= 100
}
</code></pre>
<p>More details can be seen at the original answer, here  I just cite some that are useful for myself.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Algorithms]]></title>
        <id>https://RenzoWang.github.io/Notes.github.io/post/algorithms/</id>
        <link href="https://RenzoWang.github.io/Notes.github.io/post/algorithms/">
        </link>
        <updated>2021-03-20T09:40:29.000Z</updated>
        <summary type="html"><![CDATA[<p>LeetCode</p>
]]></summary>
        <content type="html"><![CDATA[<p>LeetCode</p>
<!-- more -->
<h1 id="数组">数组</h1>
<h2 id="26-删除排序数组中的重复项">26. 删除排序数组中的重复项</h2>
<pre><code class="language-cpp">class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        
        int count = 0;
        int index = 0;

        if((nums.empty())|| (nums.size() == 0))
        {
            std::cout &lt;&lt; &quot;nums is empty or NULL!&quot; &lt;&lt; std::endl;
            return 0;
        }

        for(int i = 1; i &lt; nums.size(); i++ )
        {
           if(nums[i] == nums[index])
           {
               count++;
           }
           else
           {
               nums[i-count] = nums[i];
               index++;
           }

        }

        return nums.size() - count;
    }
};
</code></pre>
<h2 id="48旋转图像">48.旋转图像</h2>
<p>给定一个 <em>n × n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在 <strong>原地</strong> 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。<br>
顺时针旋转90°：<br>
[1,2],[3,4]<br>
=&gt;[3,1],[4,2];<br>
其中可以看出：</p>
<p>(i,j)顺时针旋转90°为(j,row-1-i);<br>
若继续旋转90°为(row-1-i,col-1-j);<br>
再顺时针旋转90°为(col-1-j,i);<br>
可以知道将矩阵中的一个数给顺时针旋转90°，也就是将四个数互相交换位置</p>
<pre><code class="language-c">    //其中row为行,col为列
    swap(matrix[i][j],matrix[col-1-j][i]);
	swap(matrix[col-1-j][i],matrix[row-1-i][col-1-j]);
	swap(matrix[row-1-i][col-1-j],matrix[j][row-1-i]);
    ```
```cpp
class Solution {
public:
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
         for(size_t i = 0;i&lt;(matrix.size()+1)/2;++i)
        {
            for(size_t j =i;j&lt;matrix.size()-i-1;++j)
            {
                swap(matrix[i][j],
                matrix[matrix.size()-1-j][i]);

                swap(matrix[matrix.size()-1-j][i],
                matrix[matrix.size()-1-i][matrix.size()-1-j]);

                swap(matrix[matrix.size()-1-i][matrix.size()-1-j]
                ,matrix[j][matrix.size()-1-i]);
            }    
        }

    }
};
</code></pre>
<h2 id="66加一">66.加一</h2>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) {
        int length = digits.size();

        for(int i=length-1; i&gt;=0; --i)
        {
            digits[i] +=1;
            //digits[i] =digits[i]%10;
            if(digits[i] == 10)
            {
                digits[i] = 0;
            }
            else
            {
                return digits;
            }
        }
        //if all digits are num 9, then the loop will not return the NUM,so The highest digit carries 1
        digits.insert(digits.begin(),1);
        return digits;

    }
};
</code></pre>
<h2 id="122-买卖股票的最佳时机-ii">122. 买卖股票的最佳时机 II</h2>
<p><strong>贪心算法</strong></p>
<pre><code class="language-cpp">class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {

        int profit = 0;
        int data = prices.size();
        if(prices.empty() || (data== 0)){
            std::cout &lt;&lt; &quot;Parameters Invalid&quot; &lt;&lt; std::endl;
        }

        for(int i=1; i &lt; data; ++i)
        {
            profit += max(0, prices[i] - prices[i-1]);
        }
        return profit;
    }
};
</code></pre>
<p>** &quot;i++&quot; 与“++i”的区别**<br>
i++ 与 ++i 的主要区别有两个：根本区别是语义上的区别<br>
<strong>a.)</strong> i++ 返回原来的值，++i 返回加1后的值。<br>
**b.) ** i++ 不能作为左值，而++i 可以。</p>
<p>如果没有用到返回值的话，区别在于效率。</p>
<ul>
<li>若i是内置的数值类型，两者完全一样</li>
<li>若i是一些自定义的类，如iterator，++i的效率 &gt; = i++的效率</li>
</ul>
<h2 id="136只出现一次的数字">136.只出现一次的数字</h2>
<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<pre><code class="language-cpp">class Solution {
public:
    int singleNumber(vector&lt;int&gt;&amp; nums) {
        int repeat = 0;

        for(int i = 0; i&lt; nums.size(); ++i)
        {
            repeat ^= nums[i];
        }
        return repeat;
    }
};
</code></pre>
<h2 id="189旋转数组">189.旋转数组</h2>
<p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p>
<pre><code class="language-cpp">class Solution {
public:
    void rotate(vector&lt;int&gt;&amp; nums, int k) {
        int length = nums.size();
        vector&lt;int&gt; temp(length);
        k = k % length; // Determine whether *k* exceeds the length of array
        
        if(nums.empty() || (nums.size()==0)){
            std::cout &lt;&lt; &quot;Invalid Parameter&quot; &lt;&lt; std::endl;
        }
        for (int i = 0; i &lt; nums.size(); i++) {
            temp[i] = nums[i];
        }
        for(int i = 0; i &lt; k; ++i)
        {
            nums[i] = temp [length-k+i];
        }
        for(int j= k; j &lt; nums.size(); ++j)
        {
            nums[j] = temp[j-k];
        }
    }
};
</code></pre>
<h2 id="217-存在重复元素">217. 存在重复元素</h2>
<p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。</p>
<pre><code class="language-cpp">class Solution {
public:
    bool containsDuplicate(vector&lt;int&gt;&amp; nums) {


        if(nums.empty() || (nums.size()==0)){
            std::cout &lt;&lt; &quot;Invalid Parameter&quot; &lt;&lt; std::endl;
        }
        sort(nums.begin(), nums.end());
        for(int i = 0; i &lt; nums.size()-1; ++i)
        {
            if (nums[i] == nums[i+1]){
                return true;
            }
        }

        return false;

    }
};
</code></pre>
<h2 id="283-移动零">283. 移动零</h2>
<p>给定一个数组 <code>nums</code>，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<pre><code class="language-cpp">class Solution {
public:
    void moveZeroes(vector&lt;int&gt;&amp; nums) {
        int length = nums.size();
       // vector&lt;int&gt; nums2(length);
        int index = 0;
        for(int i=0; i&lt;=length-1; i++)
        {
            if(nums[i] != 0)
            {
                nums[index] = nums[i];
                index++;
            }
        }

        if((length -index) &gt; 0)
        {
            for(int i = index; i &lt;= length -1; i++)
            {
                nums[i] = 0;
            }
        }
        //nums = nums2;

    }
};
</code></pre>
<h2 id="350-两个数组的交集-ii">350. 两个数组的交集 II</h2>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        sort(nums1.begin(), nums1.end());
        sort(nums2.begin(), nums2.end());  // Sort
        vector&lt;int&gt;target;

        for(vector&lt;int&gt;::iterator it1=nums1.begin(),it2=nums2.begin();it1!=nums1.end()&amp;&amp;it2!=nums2.end();)
        {
            if(*it1&lt;*it2 ) it1++;
            else if(*it1==*it2)
            {
                target.push_back(*it1);
                 it1++;
                 it2++;
            }
            else if(*it1&gt;*it2 ) it2++;
        }
        return target;
    }
};
</code></pre>
<h1 id="字符串">字符串</h1>
<h2 id="344反转字符串">344.反转字符串</h2>
<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<p><strong>对称交换</strong></p>
<pre><code class="language-cpp">class Solution {
public:
    void reverseString(vector&lt;char&gt;&amp; s) {
        int length = s.size();
        for (int i = 0; i &lt; (length+1)/2; ++i)
        {
            swap(s[i],s[length-1-i]);
        }
        

    }
};

</code></pre>
<h2 id="7整数反转">7.整数反转</h2>
<pre><code class="language-cpp">class Solution {
public:
    int reverse(int x) {
        int rev = 0;
        while(x != 0)
        {
            int pop = x %10;
            x /=10;
            if((rev &gt; INT_MAX/10))
            {
                return 0;
            }
            if((rev &lt; INT_MIN/10))
            {
                return 0;

            }
            rev = rev*10 +pop;
        }
        return rev;

    }
};
</code></pre>
<h2 id="字符串中的第一个唯一字符">字符串中的第一个唯一字符</h2>
<pre><code class="language-cpp"></code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ML]]></title>
        <id>https://RenzoWang.github.io/Notes.github.io/post/ml/</id>
        <link href="https://RenzoWang.github.io/Notes.github.io/post/ml/">
        </link>
        <updated>2021-02-17T01:41:49.000Z</updated>
        <content type="html"><![CDATA[<p>综述，机器学习的自学简单来说分为三个步骤</p>
<p>前期：知识储备包括数学知识，机器学习经典算法知识，编程技术（python）的掌握</p>
<p>中期：算法的代码实现</p>
<p>后期：实战水平提升</p>
<p>机器学习路径规划图</p>
<p>一、数学基础</p>
<p>很多人看到数学知识的时候就望而却步，数学是需要的，但是作为入门水平，对数学的要求没有那么的高。假设你上过大学的数学课（忘了也没事），需要的数学知识啃一啃还是基本能理解下来的。</p>
<p>1.1、数学内容</p>
<p>线性代数：矩阵/张量乘法、求逆，奇异值分解/特征值分解，行列式，范数等</p>
<p>统计与概率：概率分布，独立性与贝叶斯，最大似然(MLE)和最大后验估计(MAP)等</p>
<p>优化：线性优化，非线性优化(凸优化/非凸优化)以及其衍生的如梯度下降、牛顿法等</p>
<p>微积分：偏微分，链式法则，矩阵求导等</p>
<p>信息论、数值理论等</p>
<p>上面的看不太懂没事，不是特别难，学习一下就能理解了。</p>
<p>1.2、数学资源</p>
<p>网上有很多人会列举大量大量的课程资源，这是非常不负责任的事，学完那些我头发都得白了。实际上，我们只需要学习其中的一部分就够了。</p>
<p>1.2.1、吴恩达的斯坦福大学机器学习王牌课程CS229，课后就有对学生数学知识的要求和补充，这些数学知识是完全符合机器学习要求的，不多也不少。墙裂推荐要看，不过只有英文版的。</p>
<p>链接：https://pan.baidu.com/s/1NrCAW38C9lXFqPwqTlrVRA 密码：3k3m</p>
<p>1.2.2、深度学习的三大开山鼻祖之一Yoshua Bengio写的深度学习（包含了机器学习）领域的教科书，现在以开源的形式在网上公开。这部书被誉为深度学习的圣经。在这里我们只看这本书的第一部分，也就是数学基础。囊括了机器学习所需的所有必备数学基础，而且是从最基础的说起，也不多，必读的。</p>
<p>链接：https://pan.baidu.com/s/1GmmbqFewyCuEA7blXNC-7g 密码：6qqm</p>
<p>1.2.3、跟机器学习算法相结合的数学知识。上面两部分是理论层面的数学，机器学习算法中会对这些数学进行应用。</p>
<p>链接：https://zhuanlan.zhihu.com/p/25197792，知乎专栏上的一篇好文章，囊括了所有的应用知识点。</p>
<p>好了，数学方面我只推荐上面三个资源，三个都是必看的。里面很多可能你现在看不太懂，没关系。先大概过一遍，知道自己的数学水平在哪。在看到算法知识的时候，不懂的再回来补就好。后期需要更多的数学资料我会再更新的。</p>
<p>二、编程技术</p>
<p>编程语言：python3.5及以上，python易学，这个这期先不细讲。</p>
<p>三、经典算法知识</p>
<p>算法包括机器学习和深度学习，机器学习是深度学习的基础。所以务必先学机器学习的经典算法，再学深度学习的算法。</p>
<p>3.1、机器学习</p>
<p>3.1.1、课程资料</p>
<p>首推吴恩达的CS229，经典中的经典，在网易公开课里有视频，翻译，课程讲义，笔记是非常非常完备的。墙裂推荐。这个课程对数学有一定的要求，但我觉得只要你上过大学的数学，然后补一下上面的数学，完全可以直接来看这个CS229。</p>
<p>假设你的数学真的很差的话，怎么办？吴恩达在coursera上也开了一门跟CS229完全匹配的课程，coursera机器学习课。这门课是CS229的翻版，唯一不同的是它对数学基本是没有要求了，如果你对数学真的不懂的话，那就先看这个的教程吧。它跟CS229的关系就是同样的广度，但是深度浅很多，不过你学完coursera还是要回过头来看CS229的。这个也是免费的。</p>
<p>CS229课程视频：http://open.163.com/special/opencourse/machinelearning.html</p>
<p>课程讲义和中文笔记：https://pan.baidu.com/s/1MC_yWjcz_m5YoZFNBcsRSQ 密码：6rw6</p>
<p>3.1.2、配套书籍：</p>
<p>机器学习实战，必看。用代码实现了一遍各大经典机器学习算法，必须看，对你理解算法有很大帮助，同时里面也有应用。如果大家看上面纯理论的部分太枯燥了，就可以来看看这本书来知道在现实中机器学习算法是怎么应用的，会很大程度提升你的学习兴趣，当初我可是看了好几遍。</p>
<p>书籍及课后代码：链接：https://pan.baidu.com/s/15XtFOH18si316076GLKYfg 密码：sawb</p>
<p>李航《统计学习方法》，配合着看</p>
<p>链接：https://pan.baidu.com/s/1Mk_O71k-H8GHeaivWbzM-Q 密码：adep，配合着看</p>
<p>周志华《机器学习》，机器学习的百科全书，配合着看。</p>
<p>链接：https://pan.baidu.com/s/1lJoQnWToonvBU6cYwjrRKg 密码：7rzl</p>
<p>3.2、深度学习</p>
<p>说到深度学习，我们不得不提斯坦福的另一门王牌课程CS231，李飞飞教授的。这门课的课程，课后习题，堪称完美。必须必须看。整个系列下来，特别是课后的习题要做，做完之后你会发现，哇哦！它的课后习题就是写代码来实现算法的。这个在网易云课堂上有。</p>
<p>视频地址：http://study.163.com/course/introduction.htm?courseId=1004697005</p>
<p>课程笔记翻译，知乎专栏：https://zhuanlan.zhihu.com/p/21930884</p>
<p>墙裂建议要阅读这个知乎专栏，关于怎么学这门课，这个专栏写的很清楚。</p>
<p>课后作业配套答案：https://blog.csdn.net/bigdatadigest/article/category/7425092</p>
<p>3.3、学习时间</p>
<p>到这里了，你的机器学习和深度学习算是入门了。学完上面这些，按一天6小时，一周六天的话，起码也得三个月吧。上面是基本功一定要认真学。但是，还找不了工作。因为你还没把这些知识应用到实际当中。</p>
<p>3.4、实战部分</p>
<p>3.4.1、实战基础</p>
<p>这一个阶段，你要开始用tensorflow（谷歌的深度学习框架）、scikit-learn（python的机器学习框架），这两个框架极大程度地集成了各大算法。其实上面在学习cs231n的时候你就会用到一部分。</p>
<p>scikit-learn的学习：http://sklearn.apachecn.org/cn/0.19.0/</p>
<p>这是scikit-learn的官方文档中文版翻译，有理论有实战，最好的库学习资源，没有之一。认真看，传统的机器学习就是用这个库来实现的。</p>
<p>Tensorflow的学习：https://tensorflow.google.cn/api_docs/python/?hl=zh-cn</p>
<p>官方文档很详尽，还有实战例子，学习tensorflow的不二之选</p>
<p>3.4.2、实战进阶</p>
<p>仅仅看这两个教程是不够的，你需要更多地去应用这两个库。</p>
<p>接下来推荐一部神书，机器学习和深度学习的实战教学，非常非常的棒，网上有很多号称实战的书或者例子，我看了基本就是照搬官网的，只有这一本书，是完全按照工业界的流程解决方案进行实战，你不仅能学习到库的应用，还能深入了解工业界的流程解决方案，最好的实战教学书，没有之一。书名是hands-on-ml-with-sklearn-and-tf</p>
<p>链接：https://pan.baidu.com/s/1x318qTHGt9oZKQwHkoUvKA 密码：xssj</p>
<p>3.4.3、实战最终阶段</p>
<p>kaggle数据竞赛，如果你已经学到了这一步，恭喜你离梦想越来越近了：对于我们初学者来说，没有机会接触到机器学习真正的应用项目，所以一些比赛平台是我们不错的选择。参加kaggle竞赛可以给你的简历增分不少，里面有入门级别到专家级别的实战案例，满足你的各方面需求。如果你能学到这一步了，我相信也不需要再看这个了。</p>
<p>上述所有资料的合集：https://pan.baidu.com/s/1tPqsSmSMZa6qLyD0ng87IQ 密码：ve75</p>
<p>补充：</p>
<p>学到这个水平，应该是能够实习的水平了，还有很多后面再说吧。比如深度学习和机器学习的就业方向，深度学习得看论文，找工作还得对你得编程基础进行加强，具体就是数据结构与算法，我当年在这个上面可是吃了很大的亏。</p>
<p>这里面关于深度学习和机器学习的就业其实是两个方向，上面的其实也没有说全。一般来说，你得选择一个方向专攻。我建议的是，自学的最好在后期侧重机器学习方向，而不是深度学习。深度学习的岗位实在是太少，要求太高。机器学习还算稍微好点。</p>
<p>重点：上面的学习路径是主要框架，但是不意味着仅仅学习这些就够了。根据每个人基础的不同，你有可能需要另外的学习资料补充。但是，我希望大家可以按照上面的主框架走，先按上面我推荐的资源学，有需要的再去看别的（我之后也会推荐），上面的我能列出来的都是最经典的，最有效率，而且我亲身学过的。</p>
<p>后续文章：</p>
<p>上面每个学习步骤还可以细分开来，这是接下来文章的重点。比如python怎么学，cs229和cs231学习过程中会碰到什么困难，kaggle怎么用，数学还跟不上怎么办？后续都会一一说明。</p>
<p>欢迎转载，但请注明出处，尊重作者，谢谢大家了！</p>
<p>原文博主微信公众号：learningthem</p>
<h2 id="更多干货会继续分享">更多干货，会继续分享</h2>
<p>作者：q7695650<br>
来源：CSDN<br>
原文：https://blog.csdn.net/q7695650/article/details/81331328<br>
版权声明：本文为博主原创文章，转载请附上博文链接！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SQL ]]></title>
        <id>https://RenzoWang.github.io/Notes.github.io/post/eclt5840-sql/</id>
        <link href="https://RenzoWang.github.io/Notes.github.io/post/eclt5840-sql/">
        </link>
        <updated>2020-11-06T02:11:17.000Z</updated>
        <content type="html"><![CDATA[<h1 id="sql简介">SQL简介</h1>
<p>SQL是用于访问和处理数据库的标准的计算机语言，全称为Structured Query Language，可以访问和处理数据库。 是一种 ANSI（American National Standards Institute 美国国家标准化组织标准的计算机语言。</p>
<p>虽然 SQL 是一门 ANSI（American National Standards Institute 美国国家标准化组织）标准的计算机语言，但是仍然存在着多种不同版本的 SQL 语言。</p>
<p>然而，为了与 ANSI 标准相兼容，它们必须以相似的方式共同地来支持一些主要的命令（比如 SELECT、UPDATE、DELETE、INSERT、WHERE 等等）。</p>
<blockquote>
<p>除了 SQL 标准之外，大部分 SQL 数据库程序都拥有它们自己的专有扩展！</p>
</blockquote>
<h1 id="dbms">DBMS</h1>
<p>DBMS : A database-management system (<strong>DBMS</strong>) is a collection of interrelated data and a set of programs to access those data. The collection of data, usually referred to as the database</p>
<p>DBMS 中的数据存储在被称为表的数据库对象中。</p>
<p>表是相关的数据项的集合，它由列和行组成。</p>
<h1 id="sql-语法">SQL 语法</h1>
<blockquote>
<p>SQL 对大小写不敏感：即SELECT与select是相通的</p>
</blockquote>
<blockquote>
<p>某些数据库系统要求在每条 SQL 语句的末端使用分号。<br>
分号是在数据库系统中分隔每条 SQL 语句的标准方法，这样就可以在对服务器的相同请求中执行一条以上的 SQL 语句。</p>
</blockquote>
<ul>
<li>SELECT - 从数据库中提取数据</li>
<li>UPDATE - 更新数据库中的数据</li>
<li>DELETE - 从数据库中删除数据</li>
<li>INSERT INTO - 向数据库中插入新数据</li>
<li>CREATE DATABASE - 创建新数据库</li>
<li>ALTER DATABASE - 修改数据库</li>
<li>CREATE TABLE - 创建新表</li>
<li>ALTER TABLE - 变更（改变）数据库表</li>
<li>DROP TABLE - 删除表</li>
<li>CREATE INDEX - 创建索引（搜索键）</li>
<li>DROP INDEX - 删除索引</li>
</ul>
<h2 id="select-语句">select 语句</h2>
<p>SELECT 语句用于从数据库中选取数据。结果被存储在一个结果表中，称为结果集。</p>
<h2 id="select-distinct-语句">SELECT DISTINCT 语句</h2>
<p>在表中，一个列可能会包含多个重复值，有时您也许希望仅仅列出不同（distinct）的值。</p>
<p>DISTINCT 关键词用于返回唯一不同的值。</p>
<pre><code class="language-SQL">SELECT DISTINCT column_name,column_name
FROM table_name;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux添加网卡]]></title>
        <id>https://RenzoWang.github.io/Notes.github.io/post/linux-tian-jia-wang-qia/</id>
        <link href="https://RenzoWang.github.io/Notes.github.io/post/linux-tian-jia-wang-qia/">
        </link>
        <updated>2020-11-03T07:48:52.000Z</updated>
        <content type="html"><![CDATA[<p>Debian/Ubuntu系列</p>
<p>方法一：</p>
<p><code>sudo ifconfig eth0:0 192.168.1.63 up</code></p>
<p>eth0网卡上创建一个叫eth0:0的虚拟网卡,他的地址是:192.168.1.63</p>
<p>如果不想要这个虚拟网卡了,可以使用如下命令删除:</p>
<p><code>sudo ifconfig eth0:0 down</code></p>
<p>方法二：</p>
<p><code>sudo vim /etc/network/interfaces</code></p>
<p>添加并保存例如以下内容：</p>
<pre><code>auto ens33:0

iface ens33:0 inet static

address 10.60.0.1

netmask 255.0.0.0

network 192.168.1.1

broadcast 192.168.1.255
</code></pre>
<p>重启网卡生效</p>
<p><code>sudo /etc/init.d/networking restart</code></p>
]]></content>
    </entry>
</feed>